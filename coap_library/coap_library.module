<?php
/**
 *	Title: 		CoAP library
 *	Author: 	Kobe Wright
 *	Date:		16/05/2013
 */


//////////////////////////////////////////////////////////////////////////////////////////
//																						//
//									SUPPORTED FUNCTIONS									//
//									-------------------									//
//																						//
//	- coap_library_generate_message_id()												//
//	- coap_library_generate_token($token_length)										//
//	- coap_library_generate_header_and_token($type, $method, $token)					//
//	- coap_library_add_option($message, $option_number, $value)							//
//	- coap_library_add_payload($message, $payload)										//
//	- coap_library_string_to_hex_with_padding($string)									//
//	- coap_library_string_to_hex_without_padding($string)								//
//	- coap_library_dechex_with_padding($value)											//
//	- coap_library_hex_to_string($hex)													//
//	- coap_library_generate_observe_get_request($uri_path)								//
//	- coap_library_generate_basic_get_request($uri_path)								//
//	- coap_library_get_option_value($message, $option_number)							//
//	- coap_library_get_max_age($message)												//
//	- coap_library_get_payload($message)												//
//	- coap_library_get_message_id_from_message($message)								//
//	- coap_library_generate_acknowledgement($message)									//
//	- coap_library_generate_reset($response)											//
//	- coap_library_hex_to_binary($hex)													//
//	- coap_library_get_bit_from_hex($hex, $bit_number)									//
//	- coap_library_send_get_request($ip, $resource)										//
// 	- coap_library_increment_hex(&$hex)													//
//																						//
//////////////////////////////////////////////////////////////////////////////////////////

require_once('coap_library_classes.inc');

///////////////////////////////////////////////////////////////////////////////////////////
// Convert normal integer to hexadecimal string, padding when nr of characters is uneven //
///////////////////////////////////////////////////////////////////////////////////////////
function coap_library_dechex_with_padding($value){
	$value = dechex($value);
	if(strlen($value) % 2 == 1) $value = '0' . $value;
	return $value;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Convert normal string to hexadecimal string, padding when nr of characters is uneven //
//////////////////////////////////////////////////////////////////////////////////////////
function coap_library_string_to_hex_with_padding($string){
    $hex='';
	$string = '' . $string;
    for ($i=0; $i < strlen($string); $i++){
		$byte = dechex(ord($string[$i]));
		if(strlen($byte) == 1){
			$byte = "0" . $byte;
		}
        $hex .= $byte;
    }
    return $hex;
}


/////////////////////////////////////////////////////////////
// Convert normal string to hexadecimal string, no padding //
/////////////////////////////////////////////////////////////
function coap_library_string_to_hex_without_padding($string){
    $hex='';
	$string = '' . $string;
    for ($i=0; $i < strlen($string); $i++){
		$byte = dechex(ord($string[$i]));
		$hex .= $byte;
    }
    return $hex;
}


/////////////////////////////////////////////////
// Convert hexadecimal string to normal string //
/////////////////////////////////////////////////
function coap_library_hex_to_string($hex){
    $string='';
    for ($i=0; $i < strlen($hex)-1; $i+=2)
    {
        $string .= chr(hexdec($hex[$i].$hex[$i+1]));
    }
    return $string;
}


///////////////////////////////////////////////////
// Convert hexadecimal message to binary message //
///////////////////////////////////////////////////
function coap_library_hex_to_binary($hex){
	$binary = pack("H*", $hex);
	return $binary;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get bit with given number from a given hexadecimal value, returns null if bit number or hexadecimal value is invalid //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function coap_library_get_bit_from_hex($hex, $bit_number){
	if($bit_number > 3 || $bit_number < 0 || strlen($hex) != 1){
		return null;
	}
	if($bit_number == 0){
		return (hexdec($hex) % 2);
	}
	else if($bit_number == 1){
		return (hexdec($hex) == 2 || hexdec($hex) == 3 || hexdec($hex) == 6 || hexdec($hex) == 7 || hexdec($hex) == 10 || hexdec($hex) == 11 || hexdec($hex) == 14 || hexdec($hex) == 15) ? 1 : 0;
	}
	else if($bit_number == 2){
		return ((hexdec($hex) > 3 && hexdec($hex) < 8) || (hexdec($hex) > 11 && hexdec($hex) < 16 )) ? 1 : 0;
	}
	else if($bit_number == 3){
		return (hexdec($hex) > 7) ? 1 : 0;
	}
	return null;
}

function coap_library_stop_observing($module, $uri){
	$num_deleted = db_delete('coap_library_observe_resources')
		->condition('uri', $uri, '=')
		->condition('module', $module, '=')
		->execute();
}

function coap_library_get_message_id_from_message($response){
	$message_id = substr($response, 4, 4);
	return $message_id;
}
//////////////////////////////////////////
// Increments hex value.				//
// return:								//
//			1 if length hex increases	//
//			0 if length stays the same	//
//////////////////////////////////////////
function coap_library_increment_hex(&$hex){
	$hex_length =  strlen($hex);
	$hex = dechex(hexdec($hex) + 1);
	$new_hex_length = strlen($hex);
	$dif = $hex_length - $new_hex_length;
	if($dif > 0){
		for ($i = 0; $i < $dif; $i++) {
			$hex = '0' . $hex;
		}
	}
	else if($dif < 0){
		$hex = substr($hex,1);
		return 1;
	}
	return 0;
}

//	Generates a message ID that isn't yet in use
//	Message ID's get incremented every time this function is called
//	Returns numeric message id
function coap_library_generate_message_id(){
	$current_message_id;
	if($cache = cache_get('current_message_id')){
		$current_message_id = $cache->data;
	}
	else{
		$current_message_id = rand(0, 65535);
	}
	$current_message_id++;
	$current_message_id % 65536;
	cache_set('current_message_id', $current_message_id, 'cache');
	return $current_message_id;
}

//	Generates a valid token with given length
//	Tokens get incremented with each function call
//	Returns token (hexadecimal string)
function coap_library_generate_token($token_length){
	if(!is_int($token_length)){
		return null;
	}
	$token = variable_get('current_token', null);
	if($cache = cache_get('current_token')){
		$current_token = $cache->data;
	}
	else{
		$current_token = rand(0, 65535);
	}
	$current_token++;
	$current_token % 65536;
	cache_set('current_token', $current_token, 'cache');
	$current_token = dechex($current_token);
	$token_string = strval($current_token);
	$token_string = str_pad($token_string, $token_length*2, "0", STR_PAD_LEFT);
	//error_log("coap_library_generate_token, returning:" . $token_string);
	return substr($token_string, 0, $token_length*2);
}

//	Retrieves the numeric code of the given hexadecimal message
function coap_library_get_numeric_message_code_from_hex_message($hex_message){
	return hexdec(substr($hex_message, 2, 2));
}

//	Retrieves the payload, if present, from a given hexadecimal message
//	Returns null if no payload is present
//	Returns payload in hexadecimal form
// CoAP v08: this function would require looping over all the options, disabled for now...
/*function coap_library_get_payload_from_hex_message($hex_message){
	if(strlen($hex_message) < 8){
		return null;
	}
	$pos = strrpos($hex_message, 'ff', 0);
	if(!$pos){
		return null;
	}
	return substr($hex_message, $pos+2);
}*/

// Retrieves the max-age value, if present, from a given hexadecimal message
// Returns 0 if no max age option is included
function coap_library_get_max_age_from_hex_message($hex_message){
	$max_age_hex = $this->get_option_value_from_hex_message($hex_message, 14);
	if(!$max_age_hex){
		return 0;
	}
	return hexdec($max_age_hex);
}

// Extracts the hexadecimal value of the option with given number from a hexadecimal message
// Returns -1 if the option with given number is not present
// Coap v08:
function coap_library_get_option_value_from_hex_message($hex_message, $option_number){
	$follow_up = $hex_message . "\r\n";
	if(strlen($hex_message) < 8){
		return -1;
	}
	$pos = 8; // skip to start of options
	$current_number = 0;
	if($pos < strlen($hex_message)){
		$option_delta = hexdec(substr($hex_message, $pos, 1));
		$option_length = hexdec(substr($hex_message, $pos+1, 1));
		if($option_length == 15) {
			$option_length = 15 + hexdec(substr($hex_message, $pos+2, 1));
		}
		$option_length *= 2;
	}
	while($pos < strlen($hex_message) && $option_number > $current_number + $option_delta){
		$follow_up .= "nr: " . ($current_number + $option_delta) . ", length: " . $option_length . "; ";
		$current_number += $option_delta;
		// increment $pos:
		if($option_length >= 15*2) {
			$pos += 3 + $option_length; // skip additional nibble for longer length field
		} else {
			$pos += 2 + $option_length;
		}
		if($pos < strlen($hex_message)){
			$option_delta = hexdec(substr($hex_message, $pos, 1));
			$option_length = hexdec(substr($hex_message, $pos+1, 1));
			if($option_length == 15) {
				$option_length = 15 + hexdec(substr($hex_message, $pos+2, 1));
			}
			$option_length *= 2;
		}
	}
	$follow_up .= "nr: " . ($current_number + $option_delta) . ", length: " . $option_length;
	if($pos > strlen($hex_message) || $option_number != $current_number + $option_delta){
		return -1;
	}
	if($option_length >= 15*2) {
		return substr($hex_message, $pos+3, $option_length); // skip additional nibble for longer length field
	} else {
		return substr($hex_message, $pos+2, $option_length);
	}
}
// CoAP v13+:
/*
function coap_library_get_option_value_from_hex_message($hex_message, $option_number){
	$follow_up = $hex_message . "\r\n";
	if(strlen($hex_message) < 8){
		return -1;
	}
	$token_length = hexdec(substr($hex_message, 1, 1));
	if(strlen($hex_message) < 8+($token_length*2)){
		return -1;
	}
	$pos = 8 + ($token_length*2);
	$current_number = 0;
	if($pos < strlen($hex_message)){
		$extra = 0;
		$option_delta = hexdec(substr($hex_message, $pos, 1));
		if($option_delta == 13){
			$option_delta = hexdec(substr($hex_message, $pos+2, 2))-13;
			$extra += 2;
		}
		else if($option_delta == 14){
			$option_delta = hexdec(substr($hex_message, $pos+2, 4))-269;
			$extra += 4;
		}
		$option_length = hexdec(substr($hex_message, $pos+1, 1));
		if($option_length == 13){
			$option_length = hexdec(substr($hex_message, $pos+2+$extra, 2))-13;
			$extra += 2;
		}
		else if($option_length == 14){
			$option_length = hexdec(substr($hex_message, $pos+2+$extra, 4))-269;
			$extra += 4;
		}
		$option_length *= 2;
	}
	while($pos < strlen($hex_message) && $option_number > $current_number + $option_delta){
		$follow_up .= "nr: " . ($current_number + $option_delta) . ", length: " . $option_length . "; ";
		$current_number += $option_delta;
		$pos += 2 + $extra + $option_length;
		if($pos < strlen($hex_message)){
			$extra = 0;
			$option_delta = hexdec(substr($hex_message, $pos, 1));
			if($option_delta == 13){
				$option_delta = hexdec(substr($hex_message, $pos+2, 2))-13;
				$extra += 2;
			}
			else if($option_delta == 14){
				$option_delta = hexdec(substr($hex_message, $pos+2, 4))-269;
				$extra += 4;
			}
			$option_length = hexdec(substr($hex_message, $pos+1, 1));
			if($option_length == 13){
				$option_length = hexdec(substr($hex_message, $pos+2+$extra, 2))-13;
				$extra += 2;
			}
			else if($option_length == 14){
				$option_length = hexdec(substr($hex_message, $pos+2+$extra, 4))-269;
				$extra += 4;
			}
			$option_length *= 2;
		}
	}
	$follow_up .= "nr: " . ($current_number + $option_delta) . ", length: " . $option_length;
	if($pos > strlen($hex_message) || $option_number != $current_number + $option_delta){
		return -1;
	}
	return substr($hex_message, $pos+2+$extra, $option_length);
}
 */

//	Adds an option with given number and value to the given hexadecimal message
//	Expects the given option value to be hexadecimal
//	Returns null if message is smaller than 4 bytes
//	IMPORTANT: options MUST be added in order of growing option deltas
function coap_library_add_option_to_hex_message(&$hex_message, $option_number, $value){
	//error_log("coap_library_add_option_to_hex_message: adding option with (nr,value) = ($option_number,$value)");
	if(strlen($hex_message) < 8){ // hex_messageg must be at least 4 bytes long (i.e. the CoAP header)
		return null;
	}
	// Unable to get token length from header in coap 08:
	//$token_length = hexdec(substr($hex_message, 1, 1));
	/*if(strlen($hex_message) < 8 + ($token_length*2)){
		return null;
	}*/
	//pointer pos goedzetten om volgende optie toe te voegen
	//$pos = 8 + ($token_length*2);
	$pos = 8;
	$current_number = 0;
	//$option_delta = hexdec(substr($hex_message, $pos, 1));
	// Loop over already added options?
	while($pos < strlen($hex_message) && $option_number >= $current_number){
		$option_delta = hexdec(substr($hex_message, $pos,1));
		//error_log("coap_library_add_option_to_hex_message: read delta = $option_delta");
		$current_number += $option_delta;
		$pos++; // skip option delta nibble
		if(hexdec(substr($hex_message, $pos,1) == "f")) {
			$pos++; // skip 0xf nibble of option length
			$length = 15 + hexdec(substr($hex_message, $pos,1)); // option value is 15 + Length
			$pos += 2; // skip additional byte for the extended length encoding
			$pos += 2*$length; // skip option value nibbles
		} else {
			$length = hexdec(substr($hex_message, $pos,1));
			//error_log("coap_library_add_option_to_hex_message: read length = $length");
			$pos++; // skip nibble of length
			$pos += 2*$length; // skip option value nibbles
		}
	}

	$value_length = strlen($value)/2;

	// Add Option Delta, Length and Value to message
	while($option_number - $current_number > 15) { // delta > 15, must insert 1 or more fencepost options
		// Insert (delta,len) for nearest fencepost option
		$nearest_fencepost_option = (((int)($option_number / 14))+1)*14;
		$hex_message .= dechex(($nearest_fencepost_option - $current_number)*16 + 0); // Length of fencepost options is always 0
		$current_number = $nearest_fencepost_option;
	}
	// Now the delta to the option is <= 15, check whether option length needs specials treatment first:
	if($value_length > 270) {
		error_log("Option value length larger than 270 not supported");
		return;
	} else if($value_length > 14) {
		$hex_message .= str_pad(dechex(($option_number - $current_number)*16 + 15), 2, "0", STR_PAD_LEFT);
		$hex_message .= str_pad(dechex($value_length - 15), 2, "0", STR_PAD_LEFT);
	} else {
		$hex_message .= str_pad(dechex(($option_number - $current_number)*16 + $value_length), 2, "0", STR_PAD_LEFT);
	}
	//error_log("coap_library_add_option_to_hex_message: added option #".$option_number." (delta,length) = (" . ($option_number-$current_number) . ",".$value_length.")");
	// Finally insert the value of the option:
	if($value != "0")
		$hex_message .= $value;
}

// 	Adds a payload to the given message, if not yet present
//	Returns null if the message is shorter than 4 bytes or if the message already has a payload
function coap_library_add_payload_to_hex_message(&$hex_message, $payload){
	if(strlen($hex_message) < 8){
		return null;
	}
	// CoAP v08:
	if($payload != '' && $payload != null){
		$hex_message .= $payload;
	}
	// CoAP v12+:
	/*if(strpos($hex_message, 'ff', 0)){
		return null;
	}
	if($payload != '' && $payload != null){
		$hex_message .= 'ff' . $payload;
	}*/
}

//	Retrieves the textual representation of the code of the given hexadecimal message
function coap_library_get_message_code_from_hex_message($hex_message){
	$constants = new CoAPConstants();
	
	$code_nr = hexdec(substr($hex_message, 2, 2));
	return $constants->response_code_mapping[$code_nr];
}

//	Retrieves the numeric type of the given hexadecimal message
//	Return null if type is invalid
function coap_library_get_numeric_type_from_hex_message($hex_message){
	$hex = substr($hex_message, 0, 1);
	switch ($hex) {
		case "4":
			return 0;
			break;
		case "5":
			return 1;
			break;
		case "6":
			return 2;
			break;
		case "7":
			return 3;
			break;
		default:
			return null;
	}
}

//	Retrieves the token length from a given hexadecimal message (Coap v13+ 
//	only)
function coap_library_get_token_length_from_hex_message($hex_message){
	return hexdec(substr($hex_message, 1, 1));
}

//	Retrieves the token from a given hexadecimal message
function coap_library_get_token_from_hex_message($hex_message){
	// COAP v08:
	return coap_library_get_option_value_from_hex_message($hex_message, 11);
	// COAP v13:
	//$token_length = intval(coap_library_get_token_length_from_hex_message($hex_message));
	//return substr($hex_message, 8, $token_length*2);
}
