<?php

// function sensor_menu() {

  // $items = array(); 
  
  // $items['sensor/form'] = array(
    // 'title' => 'Sensor network',
    // 'page callback' => 'drupal_get_form',
    // 'page arguments' => array('sensor_form'),
    // 'access callback' => TRUE,
    // 'description' => 'Sensor network',
    // 'type' => MENU_NORMAL_ITEM,
    // 'weight' => 1,
  // );
  // return $items;
//}

function sensor_menu() {
  $items = array();
  $items["discover/ajax"] = array(
    "title" => "Discovery",
    "page callback" => "sensor_page_callback",
    "access callback" => true,
    "type" => MENU_CALLBACK
  );
  return $items;
}

function build_headers(){
return array
  (
    // 'link_name' => t('link name'),	
	// 'rt' => t('application-specific semantic type'),
	// 'ct' => t('content-type'),
	// 'if' => t('interface desciption'),
	// 'sz' => t('maximum size'),
	// 'title' => t('human-readable name'),
	// 'anchor' => t('anchor'),
	// 'rel' => t('rel'),
	
	'link_name' => t('link name'),
	'title' => t('human-readable name'),
  );
}

function build_options($links){
  $options = array();
  foreach($links as $link)
  {
    $options[$link['uid']] = array // each element of the array is keyed with the UID
    (
		// 'link_name' => $link['link_name'],
		// 'rt' => $link['rt'],
		// 'ct' => $link['ct'],
		// 'if' => $link['if'],
		// 'sz' => $link['sz'],
		// 'title' => $link['title'],
		// 'anchor' => $link['anchor'],
		// 'rel' => $link['rel'],	
		
		'link_name' => $link['link_name'],
		'title' => $link['title'],
	);
  }
  return $options;
}

function sensor_form($form, &$form_state) {	
  //textfield for device url
  $form['device_url'] = array
  (
    '#type' => 'textfield',
	'#title' => t('Device IPv6 adress'),
	'#size' => 60,
	'#required' => TRUE,
  );
  
  //geef default waarde op indien er al iets stond in tekstveld
  if (isset($form_state['sensor']['device_url'])) {
    $form['device_url']['#default_value'] = $form_state['sensor']['device_url'];
  }
  
  //button to reload the well-know/core
  $form['reload_device'] = array
  (
    '#type' => 'submit',
    '#value' => t('Reload device'),
	'#submit' => array('reload_device_core'),
  );
  
  //button to clear tableselect
  $form['clear_tableselect'] = array
  (
    '#type' => 'submit',
    '#value' => t('Clear'),
	'#submit' => array('clear_tableselect'),
  );
  
  //haal dingen op uit db als reload_core=1
  if (isset($form_state['sensor']['reload_core']) && $form_state['sensor']['reload_core'] == 1) {
	// $device_url = $form_state['sensor']['device_url'];
	// $query = db_select('core_links', 'links')
		// ->fields('links', array('device_url','link_name','title'))
		// ->condition('device_url', $device_url, '=');
	// $result = $query->execute();
	// $links = array();
	// $uid = 1;
	// foreach($result as $record){
		// array_push($links, 
			// array( 	'uid' => $uid,
					// 'link_name' => $record->link_name,
					// 'rt' => '',
					// 'ct' => '',
					// 'if' => '',
					// 'sz' => '',
					// 'title' => $record->title,
					// 'anchor' => '',
					// 'rel' => ''));
		// $uid++;
	// }

	$device_url = $form_state['sensor']['device_url'];
	$query = db_select('core_links', 'links')
		->fields('links', array('device_url','link_name','title'))
		->condition('device_url', $device_url, '=');
	$result = $query->execute();
	$links = array();
	$uid = 1;
	foreach($result as $record){
		array_push($links, 
			array( 	'uid' => $uid,
					'link_name' => $record->link_name,
					'title' => $record->title));
		$uid++;
	} 
	
  }
  else {
	$links = array();
  }
  
  //build headers
  $header = build_headers();
  
  //build options
  $options = build_options($links);
  
  $form['table'] = array
  (
    '#type' => 'tableselect',
    '#header' => $header,
    '#options' => $options,
    '#empty' => t('No sensors found'),
	'#multiple' => FALSE,
  );
  //--------------------------------------------------------------------
  
  //button to watch the selected sensor (like in cupper)
  $form['select'] = array
  (
    '#type' => 'submit',
    '#value' => t('Select'),
	'#submit' => array('show_sensor'),
  );
  
  //dpm('Klik niet op reload device want er zit een fout in het programma!');
  
  for($i=0 ; $i<6 ; $i++){
	//dpm(variable_get("response_string_$i",0));
	//dpm(variable_get("response_string_$i",0));
	//dpm($i . ': ' . variable_get("discovery_request_$i", 0) . ' gelijk aan 4? ' . variable_get("next_length_$i",0));
	//dpm(variable_get("response_string_$i",0));
	//dpm(variable_get("response_hex_string_$i",0));
	//dpm(variable_get("option23_$i",0));
	//dpm(variable_get("bool_response_$i",0));
	//dpm(variable_get("has_next_$i", 0));
	//dpm(variable_get("has_next_$i", 0) . '|' . variable_get("message_id_$i", 0) . '|' . variable_get("message_id_next_$i", 0));
	//dpm('---------------------------------------------------');
  }
  //dpm(variable_get('discovery_request_1',0));
  //dpm(variable_get('discovery_request',0));
  //$pattern = '/([^\/]+)\/(.*)/i';
  $regex = '/^(((?=(?>.*?(::))(?!.+\3)))\3?|([\dA-F]{1,4}(\3|:(?!$)|$)|\2))(?4){5}((?4){2}|(25[0-5]|(2[0-4]|1\d|[1-9])?\d)(\.(?7)){3})\z/i';
  // if(preg_match($regex, $form_state['sensor']['device_url'], $matches)){		
	// dpm('hier moet ipv6 staan: ' . $form_state['sensor']['device_url']);
  // }
  
  //2001:6a8:1d80:200::2
  
  return $form;
}

//submit handler when clicked on reload device
function reload_device_core($form, &$form_state) {
  
	//background_process_start('start_discover', $form_state['values']['device_url']);  
	start_discover($form_state['values']['device_url']); //voorgrond
  
	$form_state['sensor']['reload_core'] = 1;
	$form_state['sensor']['device_url'] = $form_state['values']['device_url'];
	$form_state['rebuild'] = TRUE;
}

//submit handler when clicked on reload device
function clear_tableselect($form, &$form_state) {
  $form_state['sensor']['reload_core'] = 0;
  
  //$form_state['sensor']['device_url'] = 0;
  $form_state['rebuild'] = TRUE;
}

//submit handler when clicked on select
function show_sensor($form, &$form_state) {
  //$form_state['rebuild'] = TRUE;
}

function sensor_form_alter(&$form, &$form_state, $form_id) {
  ////dpm($form_id);  // print form ID to messages
  ////dpm($form);  // pretty print array using Krumo to messages
}

// This hook is invoked during node viewing after the node is fully loaded
function node_content_view($node, $view_mode) {	
  $node->content['sensor_form'] = drupal_get_form('sensor_form', $node);
  return $node;
}

//stuurt 1 bericht en verwerkt 1 antwoord
function start_discover($ip){
	$regex = '/^(((?=(?>.*?(::))(?!.+\3)))\3?|([\dA-F]{1,4}(\3|:(?!$)|$)|\2))(?4){5}((?4){2}|(25[0-5]|(2[0-4]|1\d|[1-9])?\d)(\.(?7)){3})\z/i';
	if(preg_match($regex, $ip, $matches)){
		$port = 5683;
		$socket = pfsockopen("udp://[" . $ip . "]", $port, $errno, $errstr); // udp-socket openen
		if (!$socket) {
			$error = TRUE;
		} else {
			$sum_payloads='';		
			$error = FALSE;
			stream_set_timeout($socket, 5, 0);
			$has_next = true;
			$counter=0;
			$response = 'empty';
			while($has_next){
				//if($counter > 100) $has_next = false;
				//variable_set('discovery_request',$counter);
				$tries = 0;
				$prev_response = $response;
				$response = 'empty';			
				while($tries < 6 && ($response == '' || $response == 'empty')){ //5 keer herproberen
					if($tries > 0)	$error = TRUE;
					$message =generate_coap_discovery_request($prev_response,$counter);
					$returnvalue = fwrite($socket, $message); // wegschrijven naar udp-socket
					if($returnvalue != FALSE){
						$response = fread($socket, 512);	// lezen van udp-socket, waarde die je meegeeft moet groter zijn dan berichtlengte
															// anders ga je de rest van het bericht krijgen de volgende keer als je leest
					}
					$tries++;
				}
				//variable_set('counter_val_' . $counter, $counter);
				//variable_set('response_hex_string_' . $counter, coap_library_string_to_hex_with_padding($response));
				//variable_set('response_string_' . $counter, $response);				
				
				if($response != '' && $response != 'empty'){ //er is een antwoord					
					$error = FALSE;
					//variable_set("bool_response_$counter",1);
					//stream_set_timeout($socket, intval(get_max_age($response)), 0);
					//$sum_payloads .= '|' . $counter . '|';
					$sum_payloads .= parse_discovery_response($response,$has_next,$counter);
					
					//if($counter>10) $has_next=false;
				}
				else{ //na herhalen geen antwoord
					$error = TRUE;
				}
				$counter++;
				
			}
			fclose($socket);
			//verwerk $response_string
			parse_discovery_payloads($ip,$sum_payloads);
		}
	}
}

function parse_discovery_payloads($ip,$payloads){
	//$payloads = '</create2>;rt="core:test";ct="0";if="core#ll";title="Create2 resource",</test>;rt="core:test";ct="0";if="core#ll";title="Default test resource",</link2>;rt="Type2 Type3";ct="0";if="If2";title="Resource with Resource Type attribute Type2 Type3",</obs>;obs;rt="observe";ct="0";if="core#ll";title="Observable resource that changes every 5 seconds",</multi-format>;rt="core:multi-format";ct="0 41";if="core#ll";title="Resources that offers different content formats and accepts the Accept option.",</large-update>;rt="block:block1";ct="0";sz="0";if="core#ll";title="Large resource that can be updated using PUT",</separate>;rt="core:separate";ct="0";if="core#ll";title="Resource not served immediately (delayed response)",</location-query>;rt="core:location-query";ct="0";if="core#ll";title="Created resource\'s location contains Location-Query options",</query>;rt="core:query";ct="0";if="core#ll";title="Resource accepting query parameters",</large>;rt="block:block2";ct="0";sz="1284";if="core#ll";title="Large resource",</link4>;rt="qweqwew";ct="0";if="core#ll";title="Resource with empty Resource Type attribute",</seg1/seg2/seg3>;rt="core:seg";ct="0";if="core#ll";title="Long path resource",</large-create>;rt="block:block1";ct="0";sz="0";if="core#ll";title="Large resource that can be created using POST",</link3>;rt="Type1 Type3";ct="0";if="foo";title="Resource with Resource Type attribute Type1 Type3",</t>;anchor="/s/temp";rel="alternate",</link1>;rt="Type1 Type2";ct="0";if="If1";title="Resource with Resource Type attribute Type1 Type2",</s>;rt="core:sensors";ct="40";if="core#ll";title="CoAP sensors",</validate>;rt="core:etag";ct="0";if="core#ll";title="ETag test resource"';
	
	$regex = '/<[^>]+>\s*(;\s*\w+\s*(=\s*(\w+|"[^"]*(\\.[^"]*)*")\s*)?)*/';
	preg_match_all($regex, $payloads, $resources);
	
	$query = db_select('core_links', 'links')
		->fields('links', array('device_url','link_name'));
	$result = $query->execute();
	foreach($result as $record){
		db_delete('core_links')
			->condition('device_url', $record->device_url, '=')
			->condition('link_name', $record->link_name, '=')
			->execute();
	} 
	
	for($i=0 ; $i < count($resources[0]) ; $i++){
		if(preg_match('/^<([^>\?]+)[^>]*>\s*(;.+)?\s*$/', $resources[0][$i], $elements)){ //tweede nul moet $i zijn
			$uri = $elements[1];
			if (preg_match('/[a-zA-Z]+:\/\/[^\/]+.*/', $uri, $bin)) {
				// absolute URI, correct
			} else {
				// fix for old Contiki implementation and others which omit the leading '/' in the link format
				if (substr($uri,0,1)!='/') $uri = '/' . $uri;
			}
			if($elements[2]){
				preg_match_all('/;\s*\w+\s*(=\s*(\w+|"([^"]*(\\.[^"]*)*)"))?/',$elements[2],$tokens);
				
				$attributes = array(
					'device_url' => $ip,
					'link_name' => $uri,
				);
				for($e=0 ; $e<count($tokens[0]) ; $e++){
					preg_match('/;\s*([^<"\s;,=]+)\s*(=\s*(([^<"\s;,]+)|"([^"]*(\\.[^"]*)*)"))?/',$tokens[0][$e],$keyvalues);
					if($keyvalues[1] != 'if') $attribute = $keyvalues[1];
					else $attribute = $keyvalues[1] . 'd';
					$attributes[$attribute] = (count($keyvalues)>2 ? ($keyvalues[4] ? $keyvalues[4] : $keyvalues[5]) : 1);
					
				}
				variable_set("response_string_$i",$attributes);
			}
			
			$id = db_insert('core_links')
			->fields($attributes)
			->execute();
		}
		else{
			variable_set("response_string_$i", 'no match');
		}		
	}	
}

function generate_coap_discovery_request($response,$counter){
	$response_hex =  coap_library_string_to_hex_with_padding($response);
	//variable_set("discovery_request_$counter", $response);
	$out = "40"; // Versie = 1, Message Type = Confirmable, Token Length = 2
	$out .= "01"; // Method = GET
	if($response == 'empty'){
		$next_id = coap_library_generate_message_id(); // Message ID
		$out .= $next_id;
		//variable_set("message_id_$counter", $next_id);
		//variable_set("message_id_next_$counter", '-----');
	}
	else{		
		$next_id = coap_library_get_message_id_from_message($response_hex);
		//variable_set("message_id_$counter", $next_id);
		if(increment_hex($next_id)){
			$next_id = coap_library_generate_message_id();
		}
		$out .= $next_id;
		//variable_set("message_id_next_$counter", $next_id);
	}
	$out .= "bb2e77656c6c2d6b6e6f776e04636f7265"; //vervanging volgende twee lijnen
	//$out .= "bb" + coap_library_string_to_hex_with_padding("well-known/");
	//$out .= "04" + coap_library_string_to_hex_with_padding("core");
	if($response != 'empty'){	  
		//opstellen van optie 23
		//onafhankelijk van lengte optie 23, halve byte	
		$opt23_response_val = coap_library_get_option_value($response_hex,23);
		//variable_set("discovery_request_$counter", $opt23_response_val . ' met lengte ' . strlen($opt23_response_val));
		//first digit  last digit
		//	  x x x x     x x x x
		// ex: 1a: 0001 1010
		if(strlen($opt23_response_val) == 2 ){ //optielengte = 1 dubbele hex	
			$first_hex_digit = substr($opt23_response_val,0,1);
			//variable_set("discovery_request_$counter", $first_hex_digit);
			$last_hex_digit = substr($opt23_response_val,1,1);
			
			$size = 0;			
			if(coap_library_get_bit_from_hex($last_hex_digit,2) == 1) $size += 4;
			if(coap_library_get_bit_from_hex($last_hex_digit,1) == 1) $size += 2;
			if(coap_library_get_bit_from_hex($last_hex_digit,0) == 1) $size += 1;
			//variable_set("response_string_0", $size);			
			$last_hex_digit = dechex($size);
			
			$carry = 0;
			$carry = increment_hex($first_hex_digit);
			$num = $first_hex_digit . $last_hex_digit;
			//variable_set("carry_$counter",0);
			if($carry){
				//variable_set("carry_$counter",1);
				$opt23 = 'c2' . '01' . $num;
			}
			else{
				$opt23 = 'c1' . $num;
			}
		}
		else if(strlen($opt23_response_val) == 4){ //optielengte = 2 dubbele hexen => ex: 01 0a
			//variable_set("next_length_$counter",1);
			//eerste van deze lengte: 01 0a => 0000 0001 0000 1010
			// met daarvoor : 		     fa => 			 1111 1010
			
			$first_hex_digit = substr($opt23_response_val,0,1);
			$second_hex_digit = substr($opt23_response_val,1,1);
			$third_hex_digit = substr($opt23_response_val,2,1);
			$last_hex_digit = substr($opt23_response_val,3,1);
			//variable_set("discovery_request_$counter", $first_hex_digit);
			
			
			$size = 0;			
			if(coap_library_get_bit_from_hex($last_hex_digit,2) == 1) $size += 4;
			if(coap_library_get_bit_from_hex($last_hex_digit,1) == 1) $size += 2;
			if(coap_library_get_bit_from_hex($last_hex_digit,0) == 1) $size += 1;
			//variable_set("response_string_0", $size);			
			$last_hex_digit = dechex($size);
			//variable_set("discovery_request_$counter", $bitstring);
			
			$carry = increment_hex($third_hex_digit);
			if($carry){
			$carry = increment_hex($second_hex_digit);
			}
			if($carry){
			$carry = increment_hex($first_hex_digit);
			}
			$num = $first_hex_digit . $second_hex_digit . $third_hex_digit . $last_hex_digit;
			//variable_set("carry_$counter",0);
			if($carry){
				//variable_set("carry_$counter",1);
				$opt23 = 'c3' . '01' . $num;
			}
			else{
				$opt23 = 'c2' . $num;
			}
		}
		else{ //optielengte = 3 dubbele hexen
			//amai dat moet nogal nen core zijn als ge hier geraakt
		}
		$out .= $opt23; // optie 23 (11+12) met lengte 1 => value=02= 0000 0 010
	}else{
	
	}
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

function parse_discovery_response($response, &$has_next,$counter){
	//of er een volgend pakket te verwachten is, zie je aan de meest linkse bit van de laatste halve byte
	//0000
	//^ 
	
	$response_hex = coap_library_string_to_hex_with_padding($response);
	
	$has_next = coap_library_get_bit_from_hex(substr(coap_library_get_option_value($response_hex,23),-1),3);
	//if($counter > 8) variable_set("has_next_$counter", "nog?:$has_next");
	
	//if($counter > 100) $has_next = false;
	return coap_library_get_payload($response_hex);
}

function generate_coap_discovery_request_a($response,$counter){
	$response_hex =  coap_library_string_to_hex_with_padding($response);
	//variable_set("discovery_request_$counter", $response);
	$out = "40"; // Versie = 1, Message Type = Confirmable, Token Length = 2
	$out .= "01"; // Method = GET
	if($response == 'empty'){
		$next_id = coap_library_generate_message_id(); // Message ID
		$out .= $next_id;
		//variable_set("message_id_$counter", $next_id);
		//variable_set("message_id_next_$counter", '-----');
	}
	else{		
		$next_id = coap_library_get_message_id_from_message($response_hex);
		//variable_set("message_id_$counter", $next_id);
		if(increment_hex($next_id)){
			$next_id = coap_library_generate_message_id();
		}
		$out .= $next_id;
		//variable_set("message_id_next_$counter", $next_id);
	}
	$out .= "bb2e77656c6c2d6b6e6f776e04636f7265"; //vervanging volgende twee lijnen
	//$out .= "bb" + coap_library_string_to_hex_with_padding("well-known/");
	//$out .= "04" + coap_library_string_to_hex_with_padding("core");
	if($response != 'empty'){	  
		//opstellen van optie 23
		//onafhankelijk van lengte optie 23, halve byte	
		$opt23_response_val = coap_library_get_option_value($response_hex,23);
		//variable_set("discovery_request_$counter", $opt23_response_val . ' met lengte ' . strlen($opt23_response_val));
		//first digit  last digit
		//	  x x x x     x x x x
		// ex: 1a: 0001 1010
		if(strlen($opt23_response_val) == 2 ){ //optielengte = 1 dubbele hex	
			$first_hex_digit = substr($opt23_response_val,0,1);
			//variable_set("discovery_request_$counter", $first_hex_digit);
			$last_hex_digit = substr($opt23_response_val,1,1);
			
			if(coap_library_get_bit_from_hex($last_hex_digit,2) == 1) $bitstring = '1';
			else $bitstring = '0';
			if(coap_library_get_bit_from_hex($last_hex_digit,1) == 1) $bitstring .= '1';
			else $bitstring .= '0';
			if(coap_library_get_bit_from_hex($last_hex_digit,0) == 1) $bitstring .= '1';
			else $bitstring .= '0';
			//variable_set("discovery_request_$counter", $bitstring);
			
			$carry = 0;
			if($bitstring == '010'){ //a = 1010 (3210)
				$carry = increment_hex($first_hex_digit);
				$last_hex_digit = 2;
			}
			else {
				$first_hex_digit = 0;
				$last_hex_digit = 2; //szx and m
			}
			$num = $first_hex_digit . $last_hex_digit;
			//variable_set("carry_$counter",0);
			if($carry){
				//variable_set("carry_$counter",1);
				$opt23 = 'c2' . '01' . $num;
			}
			else{
				$opt23 = 'c1' . $num;
			}
			//$opt23 = 'c1' . $num;	//c1 slaat op 12 bijtellen bij vorige optie, en value heeft lengte 1
		}
		else if(strlen($opt23_response_val) == 4){ //optielengte = 2 dubbele hexen => ex: 01 0a
			//variable_set("next_length_$counter",1);
			//eerste van deze lengte: 01 0a => 0000 0001 0000 1010
			// met daarvoor : 		     fa => 			 1111 1010
			
			$first_hex_digit = substr($opt23_response_val,0,1);
			$second_hex_digit = substr($opt23_response_val,1,1);
			$third_hex_digit = substr($opt23_response_val,2,1);
			$last_hex_digit = substr($opt23_response_val,3,1);
			//variable_set("discovery_request_$counter", $first_hex_digit);
			
			if(coap_library_get_bit_from_hex($last_hex_digit,2) == 1) $bitstring = '1';
			else $bitstring = '0';
			if(coap_library_get_bit_from_hex($last_hex_digit,1) == 1) $bitstring .= '1';
			else $bitstring .= '0';
			if(coap_library_get_bit_from_hex($last_hex_digit,0) == 1) $bitstring .= '1';
			else $bitstring .= '0';
			//variable_set("discovery_request_$counter", $bitstring);
			
			if($bitstring == '010'){
				$carry = increment_hex($third_hex_digit);
				$last_hex_digit = 2;
				if($carry){
					$carry = increment_hex($second_hex_digit);
				}
				if($carry){
					$carry = increment_hex($first_hex_digit);
				}
				$num = $first_hex_digit . $second_hex_digit . $third_hex_digit . $last_hex_digit;
				//variable_set("carry_$counter",0);
				if($carry){
					//variable_set("carry_$counter",1);
					$opt23 = 'c3' . '01' . $num;
				}
				else{
					$opt23 = 'c2' . $num;
				}
			}
			else {
				$first_hex_digit = 0;
				$last_hex_digit = 2; //szx and m
				$num = $first_hex_digit . $last_hex_digit;
				$opt23 = 'c1' . $num;
			}
		}
		else{ //optielengte = 3 dubbele hexen
			//amai dat moet nogal nen core zijn als ge hier geraakt
		}
		$out .= $opt23; // optie 23 (11+12) met lengte 1 => value=02= 0000 0 010
	}else{
	
	}
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

//increments reference paramater
//return:
//			1 if length hex increases
//			0 if length stays the same
function increment_hex(&$hex){
	$hex_length =  strlen($hex);
	$hex = dechex(hexdec($hex) + 1);
	$new_hex_length = strlen($hex);
	$dif = $hex_length - $new_hex_length;
	if($dif > 0){
		for ($i = 0; $i < $dif; $i++) {
			$hex = '0' . $hex;
		}
	}
	else if($dif < 0){
		$hex = substr($hex,1);
		return 1;
	}
	return 0;
}