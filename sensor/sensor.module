<?php

// function sensor_menu() {

  // $items = array(); 
  
  // $items['sensor/form'] = array(
    // 'title' => 'Sensor network',
    // 'page callback' => 'drupal_get_form',
    // 'page arguments' => array('sensor_form'),
    // 'access callback' => TRUE,
    // 'description' => 'Sensor network',
    // 'type' => MENU_NORMAL_ITEM,
    // 'weight' => 1,
  // );
  // return $items;
//}

function sensor_menu() {
  $items = array();
  $items["discover/ajax"] = array(
    "title" => "Discovery",
    "page callback" => "sensor_page_callback",
    "access callback" => true,
    "type" => MENU_CALLBACK
  );
  return $items;
}

function build_headers(){
return array
  (
    'sensor_name' => t('Sensor name'),	
	'sensor_type' => t('Sensor type'),
	'max_age' => t('Max age'),
	'supp_obs' => t('Supports observe'),
  );
}

function build_options($users){
  //empty array
  $options = array();
  // Next, loop through the $users array
  foreach($users as $user)
  {
    $options[$user['uid']] = array // each element of the array is keyed with the UID
    (
      'sensor_name' => $user['sensor_name'], // 'first_name' was the key used in the header
      'sensor_type' => $user['sensor_type'], // 'last_Name' was the key used in the header
      'max_age' => $user['max_age'],
	  'supp_obs' => $user['supp_obs'],
	);
  }
  return $options;
}

function sensor_form($form, &$form_state) {	
	// global $user;
	
	// Checkbox per observable resource
	// $query = db_select('CoAP_users', 'users');
	// $query
		// ->fields('users', array('uid', 'uri', 'observe'))
		// ->condition('uid', $user->uid,'=');
	// $result = $query->execute();
	// foreach ($result as $record){
		// $form['observe'][$record->uri] = array(
			// '#type' => 'checkbox',
			// '#title' => $record->uri,
			// '#default_value' => $record->observe,
		// );
	// }
	
	// Submit-knop
	// $form['observe']['temperatuur_udp_url_submit'] = array (
		// '#type' => 'submit',
		// '#value' => t('Observe'),
		// );
		
	// $form['#action'] = '';
	// return $form;


  //textfield for device url
  $form['device_url'] = array
  (
    '#type' => 'textfield',
	'#title' => t('Device IPv6 adress'),
	'#size' => 60,
	'#required' => TRUE,
  );
  
  //geef default waarde op indien er al iets stond in tekstveld
  if (isset($form_state['sensor']['device_url'])) {
    $form['device_url']['#default_value'] = $form_state['sensor']['device_url'];
  }
  
  //button to reload the well-know/core
  $form['reload_device'] = array
  (
    '#type' => 'submit',
    '#value' => t('Reload device'),
	'#submit' => array('reload_device_core'),
  );
  
  //button to clear tableselect
  $form['clear_tableselect'] = array
  (
    '#type' => 'submit',
    '#value' => t('Clear'),
	'#submit' => array('clear_tableselect'),
  );
  
  //haal dingen op uit db als reload_core=1
  if (isset($form_state['sensor']['reload_core']) && $form_state['sensor']['reload_core'] == 1) {
    $users = array
    (
      array('uid' => 1,
			'sensor_name' => 'iMinds temp', 
			'sensor_type' => 'temperature',
			'max_age' => '30',
			'supp_obs' => 1),
      array('uid' => 2,
			'sensor_name' => 'iMinds hum', 
			'sensor_type' => 'humidity',
			'max_age' => '30',
			'supp_obs' => 1),
      array('uid' => 3,
			'sensor_name' => 'iMinds mov', 
			'sensor_type' => 'movement',
			'max_age' => '30',
			'supp_obs' => 0),
    );  
  }
  else {
	$users = array();
  }
  
  //build headers
  $header = build_headers();
  
  //build options
  $options = build_options($users);
  
  $form['table'] = array
  (
    '#type' => 'tableselect',
    '#header' => $header,
    '#options' => $options,
    '#empty' => t('No sensors found'),
	'#multiple' => FALSE,
  );
  //--------------------------------------------------------------------
  
  //button to watch the selected sensor (like in cupper)
  $form['select'] = array
  (
    '#type' => 'submit',
    '#value' => t('Select'),
	'#submit' => array('show_sensor'),
  );
  dpm(variable_get('response_string',0));
  //dpm(generate_coap_discovery_request(false));
  //$pattern = '/([^\/]+)\/(.*)/i';
  $regex = '/^(((?=(?>.*?(::))(?!.+\3)))\3?|([\dA-F]{1,4}(\3|:(?!$)|$)|\2))(?4){5}((?4){2}|(25[0-5]|(2[0-4]|1\d|[1-9])?\d)(\.(?7)){3})\z/i';
  if(preg_match($regex, $form_state['sensor']['device_url'], $matches)){		
	dpm('hier moet ipv6 staan: ' . $form_state['sensor']['device_url']);
  }
  
  //2001:6a8:1d80:200::2
  
  return $form;
}

//submit handler when clicked on reload device
function reload_device_core($form, &$form_state) {
  
  background_process_start('start_discover', $form_state['values']['device_url']);  
  
  $form_state['sensor']['reload_core'] = 1;
  $form_state['sensor']['device_url'] = $form_state['values']['device_url'];
  $form_state['rebuild'] = TRUE;
}

//submit handler when clicked on reload device
function clear_tableselect($form, &$form_state) {
  $form_state['sensor']['reload_core'] = 0;
  //$form_state['sensor']['device_url'] = 0;
  $form_state['rebuild'] = TRUE;
}

//submit handler when clicked on select
function show_sensor($form, &$form_state) {
  //$form_state['rebuild'] = TRUE;
}

function sensor_form_alter(&$form, &$form_state, $form_id) {
  ////dpm($form_id);  // print form ID to messages
  ////dpm($form);  // pretty print array using Krumo to messages
}

// Display a node.
// This hook is invoked only on the module that defines the node's content type 
// (use hook_node_view() to act on all node views).
// This hook is invoked during node viewing after the node is fully loaded, 
// so that the node type module can define a custom method for display, 
// or add to the default display.
function node_content_view($node, $view_mode) {	
  $node->content['sensor_form'] = drupal_get_form('sensor_form', $node);
  return $node;
}

//stuurt 1 bericht en verwerkt 1 antwoord
function start_discover($ip){
	global $user;
	$regex = '/^(((?=(?>.*?(::))(?!.+\3)))\3?|([\dA-F]{1,4}(\3|:(?!$)|$)|\2))(?4){5}((?4){2}|(25[0-5]|(2[0-4]|1\d|[1-9])?\d)(\.(?7)){3})\z/i';
	if(preg_match($regex, $ip, $matches)){
		$port = 5683;
		$socket = pfsockopen("udp://[" . $ip . "]", $port, $errno, $errstr); // udp-socket openen
		if (!$socket) {
			$error = TRUE;
		} else {		
			$error = FALSE;			
			$first = TRUE;
			//optie 23 : block2 heeft als syntax:
			// 0 1 2 3 4 5 6 7
			// +-+-+-+-+-+-+-+-+	The size of the block (SZX);
			// |  NUM  |M| SZX |	whether more blocks are following (M);
			// +-+-+-+-+-+-+-+-+	the relative number of the block (NUM) within a sequence of blocks with the given size.
			$opt23 = 'c102';
			stream_set_timeout($socket, 5, 0);
			$has_next = false;
			while($first || $has_next){			
				$retries = 0;
				$response = 'empty';				
				$message = generate_coap_discovery_request($first,$opt23);
				$returnvalue = fwrite($socket, $message); // wegschrijven naar udp-socket
				if($returnvalue != FALSE){ //wegschrijven gelukt
					$response = fread($socket, 128); // lezen van udp-socket
				}
				while($retries < 5 && ($response == '' || $response == 'empty')){ //5 keer herproberen
					$error = TRUE;
					$message =generate_coap_discovery_request($first,$opt23);
					$returnvalue = fwrite($socket, $message); // wegschrijven naar udp-socket
					if($returnvalue != FALSE){
						$response = fread($socket, 128); // lezen van udp-socket
					}
					$retries++;
				}
				$first=FALSE;
				
				if($response != '' && $response != 'empty'){ //er is een antwoord
					
					$error = FALSE;				
					//stream_set_timeout($socket, intval(get_max_age($response)), 0);				
					$response_string .= parse_discovery_response(String2Hex($response),$opt23,$has_next);
					//variable_set('response_string','lengte response: ' . String2Hex($response) . ':');
					$error = TRUE;
				}
				else{ //na herhalen geen antwoord
					$error = TRUE;
				}
				
			}
			fclose($socket);
			//verwerk $response_string
			//variable_set('response_string',$response_string);
			//insert_response_into_database($response_string, $uri);
		}
	}
}

function parse_discovery_response($hex_response, &$opt23, &$has_next){
	$str_resp='';
	$opt23_response = get_coap_option_value($hex_response,23);
	if(substr($opt23_response,1,1) == 1 ){
		$num = //nummer in orde zetten
	}
	else if(substr($opt23_response,1,1) == 2){
	
	}
	else{
	
	}
	variable_set('response_string', $opt23_response);
	//$has_next = base_convert($opt23_response, 16, 2);
	$szx= "010";
	$m = "0";
	//$num = substr($opt23_response,-4)+1; //jaja kweet tis een string
	$num = "0001";
	//$opt23 = bin2hex($num . $m . $szx);
	$opt23 = $num . $m . $szx;
	$opt23 = 'c1' . dechex(bindec($opt23));	
	//variable_set('response_string','c1' . dechex(bindec($opt23)));
	return str_resp;
}

//helemaal nog niet af
function generate_coap_discovery_request($first,$opt23){
	$out = "40"; // Versie = 1, Message Type = Confirmable, Token Length = 2
	$out .= "01"; // Method = GET
	$out .= generate_message_id_udp(); // Message ID
	$out .= "bb2e77656c6c2d6b6e6f776e04636f7265"; //vervanging onderste twee lijnen
	//$out .= "bb" + String2Hex("well-known/");
	//$out .= "04" + String2Hex("core");
	if(!$first){
	  $out .= $opt23; // optie 23 (11+12) met lengte 1 => value=02= 0000 0 010
	}
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

// Message id genereren dat nog niet gebruikt werd door telkens te incrementeren
function generate_message_id_udp(){
	$message_id = variable_get('current_message_id', null);
	if(!isset($message_id)){
		$message_id = rand(0, 65535);
	}
	else{
		$message_id++;
		$message_id % 65536;
	}
	$message_id = dechex($message_id);
	$message_id_string = strval($message_id);
	$message_id_string = str_pad($message_id_string, 4, "0", STR_PAD_LEFT);
	return $message_id_string;
}

// Response verwerken en naar databank schrijven
function insert_response_into_database($response, $uri){
	$max_age = intval(get_max_age($response));
	$temperature = (double) get_temperature($response);
	
	$query = db_select('CoAP_users', 'users');
	$query
		->fields('users', array('uri', 'uid', 'observe'))
		->condition('uri', $uri, '=')
		->condition('observe', 1, '=');
	$result = $query->execute();
	
	foreach($result as $record){
		$hid = db_insert('CoAP_values')
			->fields(array(
				'original_response' => String2Hex($response),
				'value' => $temperature,
				'max_age' => $max_age,
				'uri' => $uri,
				'uid' => $record->uid,
			))
			->execute();
	}
}

// Haalt max-age uit een response
function get_max_age($response){
	$max_age_hex = get_coap_option_value($response, 14);
	return hexdec($max_age_hex);
}

// Haalt de inhoud van de optie met opgegeven nr uit de response
function get_coap_option_value($response, $nr){
	$hex_string = String2Hex($response);
	$token_length = hexdec(substr($hex_string, 1, 1));
	$position = 8 + $token_length*2;
	$option_nr = hexdec(substr($hex_string, $position, 1));
	while($position < strlen($hex_string) && $option_nr != $nr && substr($hex_string, $position, 2) != 'ff' && substr($hex_string, $position, 2) != 'FF'){
		$option_length = hexdec(substr($hex_string, $position+1, 1));
		$position += 2 + $option_length*2;
		$option_nr += hexdec(substr($hex_string, $position, 1));
	}
	if($position >= strlen($hex_string) || substr($hex_string, $position, 2) == 'ff' || substr($hex_string, $position, 2) == 'FF'){
		return 'optie niet gevonden --> ' . $response;
	}
	else{
		$option_length = hexdec(substr($hex_string, $position+1, 1));
		return substr($hex_string, $position+2, $option_length*2);
	}
}

// Haalt de payload uit een response
function get_coap_payload($response){
	$hex_string = String2Hex($response);
	$token_length = hexdec(substr($hex_string, 1, 1));
	$position = 8 + $token_length*2;
	while($position < strlen($hex_string) && substr($hex_string, $position, 2) != 'ff' && substr($hex_string, $position, 2) != 'FF'){
		$position += 2;
	}
	if($position >= strlen($response)){
		return FALSE;
	}
	else{
		return substr($response, ($position/2)+1);
	}
}

// Haalt de temperatuur uit de payload van een response
function get_temperature($response){
	$pos_temperature = get_coap_payload($response);
	if($pos_temperature == FALSE){
		return 'temperatuur niet gevonden';
	}
	else{
		$pattern = '/value\s+(.*)C/i';
		if(preg_match($pattern, $pos_temperature, $matches)){
			$temperature = $matches[1];
			return $temperature;
		}
		else{
			return 'temperatuur niet gevonden';
		}
	}
}

// Stelt de binaire data op om een Acknowledgement terug te sturen naar de server
function generate_coap_acknowledgement($response){
	$out = "60"; // Versie = 1, Message Type = Acknowledgement, Token Length = 0
	$out .= "00"; // Method = GET
	$out .= get_message_id($response); // Message ID
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

// Stelt de binaire data op om een Acknowledgement terug te sturen naar de server
function generate_coap_reset($response){
	$out = "70"; // Versie = 1, Message Type = Reset, Token Length = 0
	$out .= "00"; // Method = GET
	$out .= get_message_id($response); // Message ID
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

// karakterstring omzetten naar string met hexadecimalen
function String2Hex($string){
    $hex='';
    for ($i=0; $i < strlen($string); $i++){
		$byte = dechex(ord($string[$i]));
		if(strlen($byte) == 1){
			$byte = "0" . $byte;
		}
        $hex .= $byte;
    }
    return $hex;
}