<?php

// function sensor_menu() {

  // $items = array(); 
  
  // $items['sensor/form'] = array(
    // 'title' => 'Sensor network',
    // 'page callback' => 'drupal_get_form',
    // 'page arguments' => array('sensor_form'),
    // 'access callback' => TRUE,
    // 'description' => 'Sensor network',
    // 'type' => MENU_NORMAL_ITEM,
    // 'weight' => 1,
  // );
  // return $items;
//}

function sensor_menu() {
  $items = array();
  $items["discover/ajax"] = array(
    "title" => "Discovery",
    "page callback" => "sensor_page_callback",
    "access callback" => true,
    "type" => MENU_CALLBACK
  );
  return $items;
}

function build_headers(){
return array
  (
    'sensor_name' => t('Sensor name'),	
	'sensor_type' => t('Sensor type'),
	'max_age' => t('Max age'),
	'supp_obs' => t('Supports observe'),
  );
}

function build_options($users){
  //empty array
  $options = array();
  // Next, loop through the $users array
  foreach($users as $user)
  {
    $options[$user['uid']] = array // each element of the array is keyed with the UID
    (
      'sensor_name' => $user['sensor_name'], // 'first_name' was the key used in the header
      'sensor_type' => $user['sensor_type'], // 'last_Name' was the key used in the header
      'max_age' => $user['max_age'],
	  'supp_obs' => $user['supp_obs'],
	);
  }
  return $options;
}

function sensor_form($form, &$form_state) {	
  //textfield for device url
  $form['device_url'] = array
  (
    '#type' => 'textfield',
	'#title' => t('Device IPv6 adress'),
	'#size' => 60,
	'#required' => TRUE,
  );
  
  //geef default waarde op indien er al iets stond in tekstveld
  if (isset($form_state['sensor']['device_url'])) {
    $form['device_url']['#default_value'] = $form_state['sensor']['device_url'];
  }
  
  //button to reload the well-know/core
  $form['reload_device'] = array
  (
    '#type' => 'submit',
    '#value' => t('Reload device'),
	'#submit' => array('reload_device_core'),
  );
  
  //button to clear tableselect
  $form['clear_tableselect'] = array
  (
    '#type' => 'submit',
    '#value' => t('Clear'),
	'#submit' => array('clear_tableselect'),
  );
  
  //haal dingen op uit db als reload_core=1
  if (isset($form_state['sensor']['reload_core']) && $form_state['sensor']['reload_core'] == 1) {
    $users = array
    (
      array('uid' => 1,
			'sensor_name' => 'iMinds temp', 
			'sensor_type' => 'temperature',
			'max_age' => '30',
			'supp_obs' => 1),
      array('uid' => 2,
			'sensor_name' => 'iMinds hum', 
			'sensor_type' => 'humidity',
			'max_age' => '30',
			'supp_obs' => 1),
      array('uid' => 3,
			'sensor_name' => 'iMinds mov', 
			'sensor_type' => 'movement',
			'max_age' => '30',
			'supp_obs' => 0),
    );  
  }
  else {
	$users = array();
  }
  
  //build headers
  $header = build_headers();
  
  //build options
  $options = build_options($users);
  
  $form['table'] = array
  (
    '#type' => 'tableselect',
    '#header' => $header,
    '#options' => $options,
    '#empty' => t('No sensors found'),
	'#multiple' => FALSE,
  );
  //--------------------------------------------------------------------
  
  //button to watch the selected sensor (like in cupper)
  $form['select'] = array
  (
    '#type' => 'submit',
    '#value' => t('Select'),
	'#submit' => array('show_sensor'),
  );
  
  //dpm('Klik niet op reload device want er zit een fout in het programma!');
  
  for($i=0 ; $i<6 ; $i++){
	//dpm(variable_get("discovery_request_$i", 0));
	//dpm(variable_get("response_string_$i",0));
	//dpm(variable_get("response_hex_string_$i",0));
	//dpm(variable_get("has_next_$i", 0));
	//dpm(variable_get("message_id_$i", 0));
	//dpm(variable_get("message_id_next_$i", 0));
	//dpm('---------------------------------------------------');
  }
  //dpm(variable_get('discovery_request_1',0));
  //dpm(variable_get('discovery_request',0));
  //dpm(variable_get('response_string',0));
  //dpm(generate_coap_discovery_request(false));
  //$pattern = '/([^\/]+)\/(.*)/i';
  $regex = '/^(((?=(?>.*?(::))(?!.+\3)))\3?|([\dA-F]{1,4}(\3|:(?!$)|$)|\2))(?4){5}((?4){2}|(25[0-5]|(2[0-4]|1\d|[1-9])?\d)(\.(?7)){3})\z/i';
  // if(preg_match($regex, $form_state['sensor']['device_url'], $matches)){		
	// dpm('hier moet ipv6 staan: ' . $form_state['sensor']['device_url']);
  // }
  
  //2001:6a8:1d80:200::2
  
  return $form;
}

//submit handler when clicked on reload device
function reload_device_core($form, &$form_state) {
  
  //background_process_start('start_discover', $form_state['values']['device_url']);  
  
  $form_state['sensor']['reload_core'] = 1;
  $form_state['sensor']['device_url'] = $form_state['values']['device_url'];
  $form_state['rebuild'] = TRUE;
}

//submit handler when clicked on reload device
function clear_tableselect($form, &$form_state) {
  $form_state['sensor']['reload_core'] = 0;
  //$form_state['sensor']['device_url'] = 0;
  $form_state['rebuild'] = TRUE;
}

//submit handler when clicked on select
function show_sensor($form, &$form_state) {
  //$form_state['rebuild'] = TRUE;
}

function sensor_form_alter(&$form, &$form_state, $form_id) {
  ////dpm($form_id);  // print form ID to messages
  ////dpm($form);  // pretty print array using Krumo to messages
}

// Display a node.
// This hook is invoked only on the module that defines the node's content type 
// (use hook_node_view() to act on all node views).
// This hook is invoked during node viewing after the node is fully loaded, 
// so that the node type module can define a custom method for display, 
// or add to the default display.
function node_content_view($node, $view_mode) {	
  $node->content['sensor_form'] = drupal_get_form('sensor_form', $node);
  return $node;
}

//stuurt 1 bericht en verwerkt 1 antwoord
function start_discover($ip){
	$regex = '/^(((?=(?>.*?(::))(?!.+\3)))\3?|([\dA-F]{1,4}(\3|:(?!$)|$)|\2))(?4){5}((?4){2}|(25[0-5]|(2[0-4]|1\d|[1-9])?\d)(\.(?7)){3})\z/i';
	if(preg_match($regex, $ip, $matches)){
		$port = 5683;
		$socket = pfsockopen("udp://[" . $ip . "]", $port, $errno, $errstr); // udp-socket openen
		if (!$socket) {
			$error = TRUE;
		} else {		
			$error = FALSE;
			stream_set_timeout($socket, 5, 0);
			$has_next = true;
			$counter=0;
			$response = 'empty';
			while($has_next){
				//variable_set('discovery_request',$counter);
				$tries = 0;
				$prev_response = $response;
				$response = 'empty';				
				while($tries < 6 && ($response == '' || $response == 'empty')){ //5 keer herproberen
					if($tries > 0)	$error = TRUE;
					$message =generate_coap_discovery_request($prev_response,$counter);
					$returnvalue = fwrite($socket, $message); // wegschrijven naar udp-socket
					if($returnvalue != FALSE){
						$response = fread($socket, 512);	// lezen van udp-socket, waarde die je meegeeft moet groter zijn dan berichtlengte
															// anders ga je de rest van het bericht krijgen de volgende keer als je leest
					}
					$tries++;
				}
				variable_set('counter_val_' . $counter, $counter);
				variable_set('response_hex_string_' . $counter, String2Hex($response));
				variable_set('response_string_' . $counter, $response);				
				
				if($response != '' && $response != 'empty'){ //er is een antwoord					
					$error = FALSE;				
					//stream_set_timeout($socket, intval(get_max_age($response)), 0);
					//$sum_payloads .= '|' . $counter . '|';
					$sum_payloads .= parse_discovery_response($response,$has_next,$counter);
					if($counter>10) $has_next=false;
				}
				else{ //na herhalen geen antwoord
					$error = TRUE;
				}
				$counter++;
				
			}
			fclose($socket);
			//verwerk $response_string
			//variable_set('response_string',$counter);
			//insert_response_into_database($sum_payloads, $uri);
		}
	}
}

function parse_discovery_response($response, &$has_next,$counter){
	//of er een volgend pakket te verwachten is, zie je aan de meest linkse bit van de laatste halve byte
	//0000
	//^ 
	$has_next = coap_library_get_bit_from_hex(substr(get_coap_option_value($response,23),-1),3);
	variable_set("has_next_$counter", "nog?: $has_next");
	//$has_next = false;
	return get_coap_payload($response);
}

//helemaal nog niet af
function generate_coap_discovery_request($response,$counter){
	$out = "40"; // Versie = 1, Message Type = Confirmable, Token Length = 2
	$out .= "01"; // Method = GET
	if($response == 'empty'){
		$next_id = generate_message_id_udp(); // Message ID
		$out .= $next_id;
		variable_set("message_id_$counter", $next_id);
		variable_set("message_id_next_$counter", '-----');
	}
	else{		
		$next_id = get_message_id($response);
		variable_set("message_id_$counter", $next_id);
		if(increment_hex($next_id)){
			$next_id = generate_message_id_udp();
		}
		$out .= $next_id;
		variable_set("message_id_next_$counter", $next_id);
	}
	$out .= "bb2e77656c6c2d6b6e6f776e04636f7265"; //vervanging volgende twee lijnen
	//$out .= "bb" + String2Hex("well-known/");
	//$out .= "04" + String2Hex("core");
	if($response != '' && false){
	  
	  
		//opstellen van optie 23
		//onafhankelijk van lengte optie 23, halve byte
		$last_hex_digit = 2; //szx and m	
		$opt23_response_val = get_coap_option_value($response,23);
		//variable_set('response_string', String2Hex($response) . '::::' . $opt23_response_val);
		//variable_set('response_string', $opt23_response_val);
		if(strlen($opt23_response_val) == 2 ){ //optielengte = 1 dubbele hex
			$first_hex_digit = substr($opt23_response_val,0,1);
			if(coap_library_get_bit_from_hex(substr($opt23_response_val,1,1),0)==0
			&& coap_library_get_bit_from_hex(substr($opt23_response_val,1,1),1)==1
			&& coap_library_get_bit_from_hex(substr($opt23_response_val,1,1),2)==0){
				$carry = increment_hex($first_hex_digit);
			}
			else {
				$first_hex_digit = 0;
			}
			$num = $first_hex_digit . $last_hex_digit;
			if($carry){
			
			}
			else{
				$opt23 = 'c1' . $num;
			}
			$opt23 = 'c1' . $num;	//c1 slaat op 12 bijtellen bij vorige optie, en value heeft lengte 1
			//variable_set('response_string_1', String2Hex($response) . '::::' . $opt23_response_val);
		}
		else if(strlen($opt23_response) == 4){ //optielengte = 2 dubbele hexen
			
		}
		else{ //optielengte = 3 dubbele hexen
			
		}
	  
	  
		$out .= $opt23; // optie 23 (11+12) met lengte 1 => value=02= 0000 0 010
		//variable_set('discovery_request','0-0');
	}else{
		//variable_set('discovery_request_1','0-0');
	}
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	variable_set("discovery_request_$counter", $out);
	return $binary;
}

//increments reference paramater
//return:
//			1 if length hex increases
//			0 if length stays the same
function increment_hex(&$hex){
	$hex_length =  strlen($hex);
	$hex = dechex(hexdec($hex) + 1);
	$new_hex_length = strlen($hex);
	$dif = $hex_length - $new_hex_length;
	if($dif > 0){
		for ($i = 0; $i < $dif; $i++) {
			$hex = '0' . $hex;
		}
	}
	else if($dif < 0){
		$hex = substr($hex,1);
		return 1;
	}
	return 0;
}

// Message id genereren dat nog niet gebruikt werd door telkens te incrementeren
function generate_message_id_udp(){
	$message_id = variable_get('current_message_id', null);
	if(!isset($message_id)){
		$message_id = rand(0, 65535);
	}
	else{
		$message_id++;
		$message_id % 65536;
	}
	$message_id = dechex($message_id);
	$message_id_string = strval($message_id);
	$message_id_string = str_pad($message_id_string, 4, "0", STR_PAD_LEFT);
	return $message_id_string;
}

// Response verwerken en naar databank schrijven
function insert_response_into_database($response, $uri){
	$max_age = intval(get_max_age($response));
	$temperature = (double) get_temperature($response);
	
	$query = db_select('CoAP_users', 'users');
	$query
		->fields('users', array('uri', 'uid', 'observe'))
		->condition('uri', $uri, '=')
		->condition('observe', 1, '=');
	$result = $query->execute();
	
	foreach($result as $record){
		$hid = db_insert('CoAP_values')
			->fields(array(
				'original_response' => String2Hex($response),
				'value' => $temperature,
				'max_age' => $max_age,
				'uri' => $uri,
				'uid' => $record->uid,
			))
			->execute();
	}
}

// Haalt max-age uit een response
function get_max_age($response){
	$max_age_hex = get_coap_option_value($response, 14);
	return hexdec($max_age_hex);
}

// Haalt de inhoud van de optie met opgegeven nr uit de response
function get_coap_option_value($response, $nr){	
	$hex_string = String2Hex($response);
	$token_length = hexdec(substr($hex_string, 1, 1));
	$position = 8 + $token_length*2;
	$option_nr = hexdec(substr($hex_string, $position, 1));
	while($position < strlen($hex_string) && $option_nr != $nr && substr($hex_string, $position, 2) != 'ff' && substr($hex_string, $position, 2) != 'FF'){
		$option_length = hexdec(substr($hex_string, $position+1, 1));
		$position += 2 + $option_length*2;
		$option_nr += hexdec(substr($hex_string, $position, 1));
	}
	if($position >= strlen($hex_string) || substr($hex_string, $position, 2) == 'ff' || substr($hex_string, $position, 2) == 'FF'){
		return 'optie niet gevonden --> ' . $response;
	}
	else{
		$option_length = hexdec(substr($hex_string, $position+1, 1));
		return substr($hex_string, $position+2, $option_length*2);
	}
}

// Haalt de payload uit een response
function get_coap_payload($response){
	$hex_string = String2Hex($response);
	$token_length = hexdec(substr($hex_string, 1, 1));
	$position = 8 + $token_length*2;
	while($position < strlen($hex_string) && substr($hex_string, $position, 2) != 'ff' && substr($hex_string, $position, 2) != 'FF'){
		$position += 2;
	}
	if($position >= strlen($response)){
		return FALSE;
	}
	else{
		return substr($response, ($position/2)+1);
	}
}

// Haalt de temperatuur uit de payload van een response
function get_temperature($response){
	$pos_temperature = get_coap_payload($response);
	if($pos_temperature == FALSE){
		return 'temperatuur niet gevonden';
	}
	else{
		$pattern = '/value\s+(.*)C/i';
		if(preg_match($pattern, $pos_temperature, $matches)){
			$temperature = $matches[1];
			return $temperature;
		}
		else{
			return 'temperatuur niet gevonden';
		}
	}
}

// Stelt de binaire data op om een Acknowledgement terug te sturen naar de server
function generate_coap_acknowledgement($response){
	$out = "60"; // Versie = 1, Message Type = Acknowledgement, Token Length = 0
	$out .= "00"; // Method = GET
	$out .= get_message_id($response); // Message ID
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

// Stelt de binaire data op om een Acknowledgement terug te sturen naar de server
function generate_coap_reset($response){
	$out = "70"; // Versie = 1, Message Type = Reset, Token Length = 0
	$out .= "00"; // Method = GET
	$out .= get_message_id($response); // Message ID
	$binary = pack("H*", $out); // hexadecimaal omzetten naar binair
	return $binary;
}

// karakterstring omzetten naar string met hexadecimalen
function String2Hex($string){
    $hex='';
    for ($i=0; $i < strlen($string); $i++){
		$byte = dechex(ord($string[$i]));
		if(strlen($byte) == 1){
			$byte = "0" . $byte;
		}
        $hex .= $byte;
    }
    return $hex;
}

// Verwacht als parameter de input van een socket en geeft het message_id terug
function get_message_id($input){
	$hex = String2Hex($input);
	$message_id = substr($hex, 4, 4);
	return $message_id;
}