\chapter{CoAP}

\section{Wat is CoAP?}

CoAP is een web transfer protocol speciaal ontwikkeld voor netwerkcomponenten die beperkt zijn in zowel geheugen als energieverbruik als machine-to-machine (M2M)\nomenclature{M2M}{Machine-to-machine}communicatie. Naast het minimaliseren van de overhead concentreert CoAP zich ook op het automatiseren van taken. Het mechanisme van built-in discovery is hier een voorbeeld van. Met het verminderen van energieverbruik in het achterhoofd biedt CoAP naast synchrone ook asynchrone communicatie aan. Het biedt ook nieuwe soorten berichten aan zoals non-confirmable, piggy-backed, etc. %Als laatste merken we op dat het protocol RESTful is.\\

Het interactiemodel van CoAP is vergelijkbaar met het client/server model van HTTP. Hoewel, bij een CoAP implementatie voor M2M interacties kan een device bij de ene berichtuitwisseling client zijn, en bij de andere server. Een CoAP request is equivalent aan een HTTP request en wordt ook gestuurd van de client naar de server om een actie aan te vragen op een resource die zich op die server bevindt. De actie wordt bepaald door een method code (GET, PUT, POST of DELETE) en de resource wordt aangeduid met een Uniform Resource Identifier (URI).\nomenclature{URI}{Uniform Resource Identifier} De server antwoordt met een response die onder andere een response code (bvb. 2.05 Content) bevat.\\

Verschillend met HTTP, gebeurt de berichtenuitwisseling asynchroon over een datagram-ge\"{o}ri\"{e}nteerd transport. Dit houdt in dat berichten mogelijks verloren gaan of in een andere volgorde kunnen aankomen dan dat ze verzonden zijn. Toch voorziet CoAP enige vorm van betrouwbaarheid met een soort bericht dat kan worden bevestigd door een acknowledgement (zie verder). Wanneer zo'n bericht niet wordt bevestigd, wordt het bericht meermaals opnieuw gestuurd volgens het exponential back-off mechanisme.\\
CoAP definieert vier soorten berichten: Confirmable, Non-confirmable, Acknowledgement en Reset. Door gebruik te maken van method codes en response codes transporteren sommige van deze berichten requests of responses. In paragraaf \ref{communicatieMogelijkheden} gaan we hier dieper op in.\\

\begin{wrapfigure}{r}{0.5\textwidth}
\vspace{-10pt}
\includegraphics[width=0.5\textwidth]{fig/CoAPLaag}
\vspace{-30pt}
\caption{CoAP lagen (CoAP 14 draft)}
\vspace{-5pt}
\label{fig:CoAPLaag}
\end{wrapfigure}
We kunnen CoAP ook in het 7-lagen model plaatsen. Logisch gezien hebben we een CoAP berichtenlaag die het UDP gedeelte en de asynchroniteit van de berichten afhandelt en een request/response laag die gebruik maakt van method en response codes (zie Figuur~\ref{fig:CoAPLaag}). Nochtans bestaat CoAP in werkelijkheid slechts uit \'{e}\'{e}n laag waarbij berichtenuitwisseling en het request/response mechanisme enkel en alleen door manipulatie van de header verwezenlijkt wordt.

\subsection{Berichtformaat}

\begin{wrapfigure}{r}{0.7\textwidth}
\vspace{-20pt}
\includegraphics[width=0.7\textwidth]{fig/CoAPMessageFormat}
\vspace{-30pt}
\caption{Berichtformaat (CoAP 14 draft)}
\vspace{-10pt}
\label{fig:CoAPMessageFormat}
\end{wrapfigure}
Om een minimale overhead te realiseren worden de berichten zeer compact gehouden. We geven een kort overzicht van de onderdelen van het berichtformaat (zie Figuur~\ref{fig:CoAPMessageFormat}) en bespreken dan de belangrijke delen apart in subparagrafen. De eerste vier bytes stellen de header voor. Bemerk dus dat de header gerealiseerd wordt met slechts 4 bytes. Het veld na de header is optioneel en bevat een token waarvan de lengte aangegeven is in de header. Vervolgens zitten er nul of meer opties in het bericht.
Het laatste onderdeel van een bericht is de payload. Indien er een payload aanwezig is in het bericht, wordt die altijd voorafgegaan door een vaste byte, de payload marker (0xFF). Deze geeft het einde van de opties en het begin van de payload aan. Indien er geen payload is mag deze marker niet aanwezig zijn.

We merken hier op dat een token, opties en een payload optioneel zijn. Dit zorgt ervoor dat sommige berichten beperkt blijven tot de header van 4 bytes, wat zeer weinig is.\\

\subsubsection{Header}

Deze vier bytes worden opgedeeld in drie delen:
\begin{itemize}
\item Versiegetal (Ver): een 2-bit unsigned integer die de CoAP versie aangeeft. 
\item Typeaanduiding (T): een 2-bit unsigned integer die het berichttype aangeeft. De mogelijkheden zijn: Confirmable (0), Non-confirmable (1), Acknowledgement (2) of Reset (3).
\item Tokenlengte (TKL)\nomenclature{TKL}{ToKen Length}: een 4-bit unsigend integer die de variabele tokenlengte aangeeft.
\item Code: 8-bit unsigned integer die aangeeft of het bericht een request of een response overbrengt, of leeg is.
\item Message ID: een 16-bit unsigned integer die gebruikt wordt om duplicatie van berichten op te merken. Het wordt ook gebruikt om berichten van het type acknowledgement/Reset te linken aan berichten van het type confirmable/non-confirmable.
\end{itemize}

\subsubsection{Token}

Een token wordt gebruikt om een response te linken met een request. De lengte wordt bepaald door de TKL en is nul tot acht bytes lang. Elk bericht heeft een token, dit kan lengte nul hebben. Elke request bevat een token gegenereerd door de client. Indien de server wil dat zijn response geaccepteerd wordt, moet hij dit token zonder meer overnemen in zijn response.

\newpage

\subsubsection{Opties}

%\begin{wrapfigure}{r}{0.6\textwidth}
%\vspace{-20pt}
%\includegraphics[width=0.6\textwidth]{fig/CoAPOpties}
%\vspace{-40pt}
%\caption{CoAP optie (CoAP 14 draft)}
%\vspace{-10pt}
%\label{fig:CoAPOpties}
%\end{wrapfigure}
Opties worden opgesteld d.m.v. de Type-Length-Value (TLV)\nomenclature{TLV}{Type Length Value} notatie (zie Figuur~\ref{fig:CoAPOpties}). Er wordt een mechanisme toegepast om opties in een pakket te stoppen, dat ervoor zorgt dat het pakket compact blijft en dus bijdraagt tot een minimale overhead.

Elke optie heeft een uniek nummer, maar wanneer meerdere opties in \'{e}\'{e}n pakket worden gestopt, worden de opties niet door dat nummer aangeduid, maar door de Option Delta. De Option Delta is het verschil tussen het nummer van een optie en dat van de vorige optie.
Concreet, stel dat men na een optie met nummer 6 een optie met nummer 11 wil plaatsen, dan wordt deze laatste aangeduid met Option Delta gelijk aan 5 (11 - 6). Dit alles samen maakt dat een minimale (lege, maar daarom niet nutteloze) optie slechts 1 byte in beslag neemt. Dit heeft als gevolg dat opties na elkaar moeten worden geplaatst met oplopende Option Numbers.
\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{fig/CoAPOpties}
\vspace{-10pt}
\caption{CoAP optie (CoAP 14 draft)}
\label{fig:CoAPOpties}
\end{figure}

\newpage

\subsubsection{Verschil met HTTP}

Als we dit kort vergelijken met het berichtformaat van HTTP (zie Figuur~\ref{HTTPMessageFormat}) zien we dat er aanzienlijke verschillen zijn. Bij HTTP zijn request en response niet helemaal gelijk. We kijken eerst naar de HTTP request.

Deze is opgedeeld in drie delen. Een requestlijn die op zijn beurt opgedeeld is in drie delen, gescheiden door een spatie. Het eerste deel is de methodenaam (GET, POST, HEAD, PUT of DELETE voor HTTP 1.1). Het tweede deel is de URL van de gevraagde resource en het laatste deel is het versienummer. Vervolgens zijn er een aantal headerlijnen die bijkomende opties voorstellen. De entity body wordt gebruikt door de POST methode om gegevens door te sturen en wordt gescheiden van de headerlijnen door een lege lijn. Bijkomend wordt elke lijn (ook de lege) afgesloten met een carriage return (CR)\nomenclature{CR}{Carriage Return} en een line feed (LF\nomenclature{LF}{Line Feed}).

De HTTP response is analoog aan de request met als verschillen dat de eerste lijn opgebouwd is uit het versienummer, de statuscode die aangeeft wat het resultaat van de request inhoudt en een korte beschrijving van de status code.\\
Het is dus duidelijk dat een HTTP bericht aanzienlijk groter zal zijn dan een CoAP bericht.

\begin{figure}[h]
\vspace{10pt}
\centering
\subcaptionbox{Request}
{\includegraphics[width=0.45\textwidth]{fig/HTTPRequestMessageFormat}}
\subcaptionbox{Response}
{\includegraphics[width=0.45\textwidth]{fig/HTTPResponseMessageFormat}}
\caption{HTTP Message Format}\label{HTTPMessageFormat}
\end{figure}

\newpage

\section{Communicatiemogelijkheden} \label{communicatieMogelijkheden}

In deze paragraaf bespreken we de communicatiemogelijkheden van CoAP. We bekijken de variabele betrouwbaarheid van CoAP berichten en gaan na hoe het request/response model bij CoAP werkt aan de hand van voorbeelden.

\subsection{Betrouwbaarheid}

HTTP realiseert een betrouwbare en robuuste vorm van communicatie. Het is gebaseerd op het Transmission Control Protocol (TCP), dit protocol zet een verbinding op aan de hand van stream sockets. Het zorgt ervoor dat pakketten gegarandeerd aankomen bij de bestemming en dit in volgorde van verzending. Maar deze betrouwbaarheid komt met een prijs, namelijk extra netwerkbelasting voor het opzetten en beheren van die verbinding. In tegenstelling tot HTTP dat gebouwd is op TCP, is CoAP gebaseerd op berichtenuitwisseling over UDP. Wanneer men met dit protocol werkt, is er echter geen garantie dat pakketten aankomen en wanneer dat wel het geval is, kan de volgorde van aankomst gewijzigd zijn ten opzichte van verzending. Daarom moet men bij CoAP zelf de betrouwbaarheid implementeren indien nodig.

\subsubsection{Confirmable berichten}

\begin{wrapfigure}{r}{0.3\textwidth}
%\vspace{-20pt}
\includegraphics[width=0.3\textwidth]{fig/CoAPConfirmable}
\vspace{-30pt}
\caption{Betrouwbare berichtuiwisseling (CoAP 14 draft)}
%\vspace{-10pt}
\end{wrapfigure}
Wanneer we de betrouwbaarheid van de berichtenuitwisseling willen opdrijven, merken we de berichten als confirmable (CON)\nomenclature{CON}{Confirmable}. Een CON bericht moet door de server worden beantwoord met een Acknowledgement (ACK)\nomenclature{ACK}{Acknowledgement} bericht, dit ACK bericht moet hetzelfde message ID bevatten als het CON bericht waarop geantwoord wordt. Wanneer CON berichten niet worden beantwoord met een ACK bericht v\'{o}\'{o}r een bepaalde timeout, wordt het bericht opnieuw verzonden. Bij het opnieuw verzenden wordt een exponential back-off mechanisme toegepast. Eerst wordt een timeout bepaald tussen een ACK\_TIMEOUT en ACK\_TIMEOUT x ACK\_RANDOM\_FACTOR, wanneer die timeout verstrijkt wordt het CON bericht opnieuw verzonden en de timeout verdubbeld. Wanneer de server niet in staat is het CON bericht te verwerken, wat betekent dat die zelfs geen geldige error response kan geven, antwoordt die met een reset (RST)\nomenclature{RST}{Reset} bericht in plaats van een ACK bericht.

\subsubsection{Non-confirmable berichten}

\begin{wrapfigure}{r}{0.3\textwidth}
\vspace{-30pt}
\includegraphics[width=0.3\textwidth]{fig/CoAPNonConfirmable}
\vspace{-20pt}
\caption{Onbetrouwbare berichtuiwisseling (CoAP 14 draft)}
\vspace{-15pt}
\end{wrapfigure}

Soms heeft een bericht geen betrouwbaar transport nodig. Een voorbeeld hiervan is een stroom van sensordata waarbij elke meting verstuurd wordt met een Non-confirmable bericht(NON)\nomenclature{NON}{Non-confirmable}. Dit soort berichten wordt niet bevestigd met een ACK bericht, maar de berichten hebben wel nog steeds een message id om duplicatie van berichten te detecteren. Wanneer een ontvanger niet in staat is het bericht te verwerken, opnieuw bedoelen we daarmee dat het geen geldige error response kan geven, zendt hij een RST naar de zender.

\subsection{Request/response model}

\subsubsection{Piggy-backed response}

Wanneer een request met een CON bericht verstuurd wordt, is het mogelijk dat het antwoord meteen beschikbaar is bij de server. Indien dit het geval is, wordt het antwoord op de request meteen meegestuurd met het ACK bericht. Dit wordt een piggy-backed response genoemd. In Figuur~\ref{fig:CoAPPiggyBacked} worden twee voorbeelden van GET requests met piggy-backed responses getoond. De ene is succesvol, de andere geeft een error response terug.
\begin{figure}[h]
%\vspace{-10pt}
\centering
\includegraphics[width=0.7\textwidth]{fig/CoAPPiggyBacked}
\vspace{-10pt}
\caption{Twee GET requests met piggy-backed responses (CoAP 14 draft)}
\label{fig:CoAPPiggyBacked}
\vspace{-20pt}
\end{figure}

\subsubsection{Seperate response}

\begin{wrapfigure}{r}{0.3\textwidth}
\vspace{-40pt}
\includegraphics[width=0.3\textwidth]{fig/CoAPSeperateResponse}
\vspace{-20pt}
\caption{GET request met seperate response (CoAP 14 draft)}
\label{fig:SeperateResponse}
\vspace{-100pt}
\end{wrapfigure}
Wanneer de server niet onmiddellijk kan antwoorden op de request van de client, antwoordt die met een leeg ACK bericht zodat de client niet zou beginnen heruitzenden als gevolg van het exponential back-off mechanisme. Wanneer de response klaar is, stuurt de server dit antwoord in een nieuw CON bericht dat op zijn beurt beantwoord moet worden door de client. Dit soort van berichtenuitwisseling heet seperate response (zie Figuur~\ref{fig:SeperateResponse}).


\section{Extra Features}

\subsection{Observer}

Wanneer een resource observable is of anders gezegd, de observe functionaliteit ondersteunt, kan die resource op eigen initiatief data sturen naar eventueel ge\"{i}nteresseerde clients. Een client kan zijn interesse uiten door een CON bericht te sturen naar de server dat een lege observe option bevat. Wanneer de client dan een ACK bericht terug krijgt met een observe option, weet die dat de server de client heeft toegevoegd aan de lijst van observers. Een client kan aangeven aan de server dat die niet meer ge\"{i}nteresseerd is door een RST bericht te sturen naar de server. De server verwijdert de client dan uit de lijst van ge\"{i}nteresseerden.

\subsection{Resource discovery}

\subsection{Resource directory} %zeg hier ook wrm we niet voor service discovery gekozen hebben en we resource directory als alternatief verkiezen

