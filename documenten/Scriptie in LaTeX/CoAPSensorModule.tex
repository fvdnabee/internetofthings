\chapter{CoAP sensor module} \label{sensormodule}

Nu we genoeg kennis hebben over Drupal en CoAP en een CoAP library ter beschikking hebben, kunnen we overgaan tot de uiteindelijk te ontwikkelen module. Het is deze module die een eindgebruiker zal installeren. Ze biedt dan de mogelijkheid om op een gebruiksvriendelijke en dynamische manier sensoren te bekijken en beheren van op de Drupal-website, en dit zonder technische kennis nodig te hebben van CoAP of programmatie in PHP voor Drupal. We bekijken eerst globaal wat de module concreet moet aanbieden. Daarna bekijken we hoe de module zal opgebouwd worden en welke de principes zijn waar we veel belang aan moeten hechten bij het opbouwen. Eens we dit weten, kunnen we overgaan tot de verschillende versies van de ontwikkelde module en de implementatie ervan. Verder bespreken we de ingevoerde tabellen in de databank en de manipulatie ervan. Ook worden de ingevoerde content types bekeken.

\section{Functionaliteit}

De bedoeling van deze module is de eindgebruiker in staat te stellen om gemakkelijk sensoren te beheren op zijn/haar website. Belangrijk hierbij is dat elke Drupal-gebruiker die een website maakt, deze kan gebruiken zonder extra kennis nodig te hebben over CoAP. Ook is het niet de bedoeling dat de eindgebruiker nog moet programmeren om de module te kunnen gebruiken. Kortom, de module moet out-of-the-box werken en zoveel mogelijk omvatten wat mogelijk is met CoAP-sensoren.\\
%Concreet houdt dit onder andere in dat bij installatie van de module enkele content types mee worden ge\"{i}nstalleerd. Het betreft hier een content type voor een enkele CoAP resource en een content type voor een CoAP device waarop meerdere resources aangesloten zijn. De resources worden bij een CoAP device aangegeven onder vorm van het content type CoAP resource. Deze content types zorgen ervoor dat de gebruiker slechts met enkele muisklikken resources en devices kan toevoegen en onmiddellijk kan beginnen met het beheren en bevragen van de resources. Verder worden bij installatie ook alle benodigde databanktabellen gecre\"{e}erd.\\

Wanneer de gebruiker een resource of een device wil toevoegen, hoeft die enkel de URI van de resource of van het device op te geven. Bij het toevoegen van een resource worden de gegevens van die resource automatisch opgehaald. En bij het toevoegen van een device, worden de resources die zich in de well-known/core van het device bevinden automatisch opgehaald. De gebruiker heeft geen idee hoe dit gebeurt.
%Deze bestaat uit het IPv6-adres van het device waar de resource zich op bevindt en de naam van de resource, gescheiden door een '/'.
%De module zal aan de hand van een specifieke resource discovery, de overige informatie en parameters van de resource ophalen en opslaan in de databank (Zie paragraaf \ref{resourceDiscovery}).\\
%Bij het toevoegen van een device, hoeft de gebruiker net zoals bij een resource de URI van het device op te geven. De informatie van de resources die zin in de well-known/core van het device bevinden, worden automatisch opgehaald bij het toevoegen van dat device.
%De configuratie die de gebruiker moet doen zoals bijvoorbeeld het toevoegen van een resource, moet gebruiksvriendelijk verlopen. Hiervoor wordt gebruik gemaakt van resource discovery. In het geval van een CoAP device hoeft de gebruiker enkel het IPv6-adres ervan op te geven. Aan de hand van resource discovery wordt dan een lijst gegenereerd van resources. Wanneer de gebruiker op een resource klikt, krijgt die een visuele representatie van het content type CoAP resource.\\

Eens de gebruiker de gewenste resources heeft toegevoegd aan zijn/haar website, is het de bedoeling dat de 4 REST-methodes GET, PUT, POST, DELETE kunnen uitgevoerd worden. De gebruiker zal ervan op de hoogte gebracht worden wanneer een methode niet ondersteund wordt. Naast deze methodes kan een resource ook nog observable zijn (zie hoofdstuk \ref{CoAP}), de gebruiker moet dus ook in staat gesteld worden om notificaties te ontvangen van een resource. Ook wanneer een gebruiker de website verlaat moet het mogelijk zijn de observe te laten doorlopen.

Een gebruiker moet ook in staat zijn gepersonaliseerde lijsten samen te stellen van verschillende resources en/of devices.

\section{Architectuur}
In deze paragraaf bespreken we de architectuur van de module en hoe die inpast in het Drupal-systeem. We behandelen tevens ook enkele belangrijke aspecten die in rekening werden gebracht. %Vervolgens lichten we enkele belangrijke onderdelen van de module toe.\\

\subsection{Requestproces}
Het proces voor het opvragen van een resourcewaarde wordt weergegeven in figuur \ref{fig:architectuur}. De acties aangeduid met een gekleurd bolletje gebeuren altijd bij een request, de acties aangeduid met een leeg bolletje zullen pas gebeuren wanneer geen geldige waarde uit de databank kan worden gehaald (Zie paragraaf \ref{caching}). We overlopen de opeenvolgende stappen:
\begin{enumerate}
\item De client start een periodieke poll naar de webserver waarop Drupal draait. Deze poll gebeurt onder vorm van een AJAX call.
\item De CoAP Sensor module voert een query uit op de databank om een geldige waarde op te vragen indien die aanwezig is.
\item De databank stuurt een resultatenset terug die een geldige waarde bevat, of leeg is indien er geen geldige waarde meer is.
\item In deze stap zijn er twee mogelijkheden:
\begin{itemize}
\item Indien er een geldige waarde aanwezig is in de databank, wordt deze teruggestuurd naar de client als antwoord op de AJAX call. De request eindigt dan hier.
\item Indien er geen geldige waarde aanwezig is in de databank, wordt een beroep gedaan op de CoAP library module om een nieuwe waarde op te vragen aan de resource. 
\end{itemize}
Dit mechanisme zorgt ervoor dat de sensor niet onnodig belast wordt (Zie paragraaf \ref{caching}).
\item De CoAP library module stuurt een CoAP GET-request naar de resource.
\item De resource stuurt zijn waarde terug in een response bericht als antwoord op de GET-request.
\item De CoAP library roept een hook op die de CoAP Sensor module ge\"{i}mplementeerd heeft, om die ervan op de hoogte te brengen dat er een waarde is binnengekomen.
\item De hook zal ervoor zorgen dat de nieuwe, ontvangen waarde opgeslagen wordt in de databank.
\item Uiteindelijk wordt de waarde ook teruggestuurd naar de client die de request heeft gestart.
\end{enumerate}
\begin{figure}
\includegraphics[width=1\textwidth]{fig/architectuur}
\caption{Resourcewaarde opvragen met de CoAP sensor module in Drupal}
\label{fig:architectuur}
\end{figure}

\subsection{Belangrijke aspecten}

Deze module werd ontworpen met het oog op bepaalde aspecten waarmee rekening moet worden gehouden. We sommen enkele van de belangrijkste op.

\subsubsection{Modulariteit}
Een van de grote troeven van Drupal is de modulariteit die aangeboden wordt. Het is dan ook van uiterst belang dat onze module dit principe niet verbreekt, maar juist doorzet. In hoofdstuk \ref{coaplibrary} zagen we al hoe een aparte CoAP library ontwikkeld werd. Dit heeft als gevolg dat elke Drupal-gebruiker de kans heeft gebruik te maken van deze library en dus zelf een module zou kunnen bouwen gelijkaardig aan de onze.\\
%Dit geldt ook voor deze module die we nu bespreken, deze is ook bruikbaar voor elke gebruiker die dat wil. Naast het installeren van de CoAP library en deze module, hoeft de gebruiker niets extra te doen om deze module te gebruiken. Databanktabellen worden gecre\"{e}erd en content types worden ge\"{i}nstalleerd, zonder dat de gebruiker daar iets hoeft voor te configureren.\\
De Sensor module maakt nog gebruik van enkele andere modules welke eerst moeten ge\"{i}nstalleerd worden door de gebruiker vooraleer hij gebruik kan maken van de Sensor module. Drupal zal bij installatie van de CoAP Sensor module automatisch aangeven welke modules eerst moeten worden ge\"{i}nstalleerd. Het betreft de volgende modules:
\begin{itemize}
\item Background Process \cite{backgroundProcessModule}: Deze module maakt het gebruik van achtergrondprocessen mogelijk. (bvb voor observe)
\item Progress \cite{progressModule}: Deze module moet worden toegevoegd omdat de Background Process module hiervan afhankelijk is.
\item CoAP library (Zie hoofdstuk \ref{coaplibrary}): Onze eigen geschreven module die instaat voor alle CoAP communicatie.
\item Entity API \cite{entityApiModule}: Een veelgebruikte module (die opgenomen wordt in de core van Drupal 8). Breidt de functionaliteit uit die met entities kan verwezenlijkt worden. Deze module wordt besproken in \ref{gebruikEntityAPI}.
\item Node reference \cite{nodeReferenceModule}: Een module die gebruikt wordt om in een bepaalde node door middel van een veld te verwijzen naar andere nodes.
\end{itemize}

\noindent
Er zijn ook modules die niet strikt noodzakelijk zijn maar wel extra functionaliteit bieden:
\begin{itemize}
\item Views\cite{viewsModule}: Maakt het gebruik van views mogelijk.
\item Views UI: Stelt een user interface ter beschikking om eigen views te maken en te beheren. Deze module is onderdeel van de views module.
\end{itemize}

\subsubsection{Minimalisatie van netwerkbelasting}
Mogelijks zijn meerdere gebruikers van een Drupal-website ge\"{i}nteresseerd in een observable resource. Het is niet aanvaardbaar dat de netwerkbelasting zou stijgen met het aantal ge\"{i}nteresseerden voor die resource. Daarom gedraagt Drupal zich eigenlijk als intermediaire server voor de eindgebruikers. Er wordt namelijk maar \'{e}\'{e}n observe op die resource uitgevoerd door Drupal, ongeacht het aantal gebruikers dat ge\"{i}nteresseerd is in die resource. De notificaties worden op de server in de databank gestopt en het zijn deze waarden waarop de gebruikers uiteindelijk pollen. %\\
%Bovendien zorgt dit voor een vorm van controle over verkeer naar de resources, de gebruikers van de website kunnen namelijk niet zelfstandig CoAP praten met de resources. % Een voorbeeld hiervan is de demo van de module op onze website (http://www.thesisinternetofthings.tk). Enkel ingelogde gebruikers zijn in staat een observe uit te voeren. Dit om te vermijden dat gelijk wie een observe kan starten, men kan namelijk vergeten de observe af te sluiten, waardoor de databank meer en meer opgevuld wordt.

\subsubsection{Asynchroniteit}
In een eerste fase van deze module werd er gebruik gemaakt van een formulier. Bij het indienen van dit formulier, werd eerst de request om de waarde op te halen uitgevoerd en dan gewacht op de response om de nieuwe pagina op te bouwen. Het spreekt voor zich dat dit geen goede oplossing is, omdat het renderen van de pagina maar kan gebeuren nadat de response aangekomen en verwerkt is. Zo kan de gebruiker de indruk krijgen dat de verbinding met de website verbroken is wanneer de communicatie traag is of misloopt. \\

In hoofdstuk \ref{Drupal} zagen we als mogelijke oplossing het gebruikv an jQuery. In deze situatie is jQuery echter geen goede optie omdat jQuery de databank van Drupal niet zonder bijkomende informatie kan manipuleren. Hiervoor zouden een connectiestring, wachtwoord en dergelijke gegevens nodig zijn. JQuery van die informatie voorzien is een grote bedreiging voor de veiligheid. Bovendien zou dit een oplossing zijn met een zeer sterke koppeling, wat nooit een goed idee is.\\
De gebruikte oplossing illustreert alweer de voordelen van een open source platform met een uitgebreide community. Er is namelijk al een Background Process module gemaakt, het zou dus zonde zijn om hier niet dankbaar gebruik van te maken. Zoals de naam suggereert, biedt de Background Process module de mogelijkheid om achtergrondprocessen op te starten. Deze draaien op de achtergrond op de server en storen dus geen andere processen zoals het opbouwen van een pagina voor de gebruiker. De gebruiker wordt dus niet meer geconfronteerd met lange wachttijden.\\
Sterker nog, er is ook een functie voorzien om een HTTP GET-request uit te voeren, waarbij je een callback-functie opgeeft. Wanneer er een response is, zal dus automatisch de opgegeven functie als achtergrondproces opgeroepen worden met de response als argument. Deze functie zal dus goed van pas komen in de eerste versie van de module, die gebruik maakt van een HTTP/CoAP-proxy. Deze wordt beschreven later in dit hoofdstuk (Zie paragraaf \ref{proxy}).

\subsubsection{Strategie bij ontvangst van waarden}
\paragraph{Push-strategie:}

De mooiste oplossing en tevens degene met het minste aandeel aan overhead, is een oplossing waarbij de server zelf op eigen initiatief data kan sturen naar de client. Merk op dat we hier als server de Drupal-server bedoelen en als client de browser. Hierbij is dan geen polling-mechanisme nodig door de client, wat de netwerkbelasting drastisch verlaagt en de verantwoordelijkheid verschuift naar de server.\\
Om een push-strategie te verwezenlijken werd een uitgebreide literatuurstudie van node.js uitgevoerd. Node.js is een javascript-library die je in staat stelt bi-directioneel verkeer te verwezenlijken. Hierbij wordt gebruik gemaakt van kanalen die worden opgezet, zo'n kanaal kan dan door beide partijen gebruikt worden.\\
Concreet zou het in de context van deze masterproef mogelijk zijn om met node.js een JavaScript-functie op te roepen bij de client op initiatief van de server.\\

Er is meermaals gepoogd dit te realiseren, maar de summiere documentatie van node.js laat op sommige vlakken te wensen over. Zo zijn we er niet in geslaagd documentatie te vinden over het opzetten van een eigen kanaal of een bestaand kanaal te gebruiken.\\
Bovendien is het nodig voor node.js om een extra server te draaien waarlangs het verkeer moet passeren. Aangezien het vaak niet mogelijk is om de shell van de webserver te gebruiken in een free-hosting omgeving, is dit een erg groot nadeel. Er bestaan wel servers die je kan gebruiken, maar dit tegen betaling. Wij, als ontwikkelaar van de module, kunnen niet verwachten dat een eindgebruiker een extra server ter beschikking heeft of dat zelfs wil. Het is de bedoeling dat onze module zo veel mogelijk out-of-the-box bruikbaar is.\\

De conclusie is dat wij geopteerd hebben geen gebruik te maken van node.js en dus ook niet van een push-strategie.

\paragraph{Pull-strategie: }

Aangezien een push-strategie niet of moeilijk kan gebruikt worden, hebben wij gekozen voor een pull-oplossing.\\

Uiteraard was de eerste reactie gebruik te maken van de Drupal-community en dus te zoeken in de vele modules die beschikbaar zijn. Er is tot op heden geen module geschreven door iemand anders in de Drupal-community dat ons probleem behandelt. De inspiratie voor de uiteindelijke oplossing werd wel gehaald uit een bestaande module, namelijk de Block Refresh-module \cite{blockRefreshModule}.\\
Deze laatste maakt gebruik van jQuery en AJAX calls om periodiek de inhoud van een block te refreshen, waarbij je zelf de lengte van de periode kan bepalen. In jQuery loopt een timer die periodiek een JavaScript-functie oproept. In deze functie wordt dan een AJAX call uitgevoerd naar de Drupal-server, die op zijn beurt een antwoord terug stuurt.\\

Wij hebben geopteerd het mechanisme licht te wijzigen in plaats van de module zelf te gebruiken. Aan de basis van deze beslissing liggen drie redenen:
\begin{itemize}
\item Wij wensen de content slechts aan te passen wanneer nodig. Dit wil zeggen, wanneer een nieuwe waarde is binnengekomen. Bovendien hoeft niet alle content vernieuwd te worden, dit doet de Block Refresh module wel.
\item De configuratie van de periode voor het vernieuwingsinterval is in onze ogen relatief omslachtig. De gebruiker moet al een configuratievenster openen om het interval te wijzigen, wat wachttijden met zich meebrengt. Het zal blijken dat in onze uiteindelijke module het interval snel en gemakkelijk te wijzigen is. 
\item De uiteindelijke module zal geen blocks meer gebruiken, maar content types. Dit maakt het gebruik van de Block Refresh module zelfs onmogelijk.
\end{itemize}

De aangepaste methode werkt als volgt: Wanneer de pagina geladen wordt bij de client, start een timer die periodiek een AJAX call uitvoert naar de Drupal-server. De gebruiker kan hierbij bepalen hoe lang die periode moet zijn. Op de Drupal-server is dan een AJAX callback functie gedefinieerd aan de hand van de hook hook\_menu(). Deze hook wordt gebruikt om menu items toe te voegen aan de site en om AJAX callbacks te definieren. Alle output die gegenereerd wordt in deze callback wordt als antwoord teruggestuurd op de AJAX callback.\\

Wat de callback terugstuurt en hoe die inhoud wordt verwerkt, verschilt per versie van onze module. Dit zal dan ook besproken worden in de gepaste paragrafen (Zie paragraaf \ref{evolutie}).

\subsubsection{Caching}\label{caching}
Een bericht kan een maximum levensduur hebben, dit wordt aangegeven met een max-age optie (optie 14) in het bericht. Deze bevat dan een numerieke waarde die aangeeft in seconden hoelang de waarde als geldig mag worden beschouwd. Wanneer deze maximum levensduur overschreden wordt, mag deze waarde niet meer worden gebruikt. Dan moet bij een volgende aanvraag door een gebruiker een nieuwe waarde worden opgehaald van de resource. Bijgevolg wordt een opgehaalde waarde in de databank gestopt. Wanneer de maximum levensduur nog niet overschreden is bij een aanvraag, wordt de waarde uit de databank gehaald. De resource en het netwerk worden dan dus niet onnodig belast. Dit zorgt er ook voor dat de belasting op een resource niet evenredig stijgt met het aantal gebruikers die er een waarde van willen opvragen.\\
Dit aspect is zeker een van de meer belangrijke omdat verbindingen naar een resource vaak een beperkte bandbreedte kennen. Bovendien bestaat de energievoorziening van sensoren vaak uit een batterij. Het werk dat zo'n sensor moet verrichten, moet dus worden geminimaliseerd.

\section{Evolutie van de module} \label{evolutie}

\subsection{Temperatuurmodule met HTTP/CoAP-proxy} \label{proxy}
In deze paragraaf wordt besproken hoe de eerste versie van de module werd gemaakt die gebruik maakt van een HTTP/CoAP-proxy. Bovendien wordt ook aangetoond hoe waarden opgeslaan worden in de databank om de geschiedenis van opvragingen bij te houden. We spreken hier (en in enkele volgende paragrafen) beter van een temperatuurmodule, aangezien deze module slechts \'{e}\'{e}n resource bevraagt. Het betreft een resource die de waarde van een temperatuursensor terugstuurt. Deze resource werd gekozen vanwege de numerieke waarde die teruggestuurd wordt en omwille van het feit dat de resource observable is.\\

De module wordt aan de gebruiker gepresenteerd onder de vorm van een Drupal-block. Dit block bevat een HTML-formulier met twee componenten die als invoer dienen. Een checkbox die aanduidt of de gebruiker waarden automatisch wil laten ophalen, en een knop die het formulier indient wanneer de gebruiker erop klikt.\\
Wanneer de gebruiker op de knop klikt en de checkbox heeft aangevinkt, worden waarden automatisch opgehaald met een interval gelijk aan de waarde van de max-age. Merk op dat het hier nog niet om een CoAP observe gaat, want die is enkel mogelijk met native CoAP. In deze module werken we met een HTTP proxy. Periodiek wordt een HTTP GET-request naar een HTML-pagina uitgevoerd. Wanneer de response ontvangen wordt, wordt de HTML-pagina geparsed, waarna de nuttige informatie in de databank wordt geplaatst. Met jQuery worden dan nieuwe waarden periodiek opgehaald en getoond aan de gebruiker.\\

Er is bij deze versie nog geen sprake van achtergrondprocessen waardoor het lang kan duren eer een pagina geladen wordt. Bovendien krijgt de gebruiker enkel een foutmelding (van de gebruikte webserver) te zien wanneer er geen communicatie mogelijk is.

\begin{figure}[h!]
\vspace{10pt}
\includegraphics[width=1\textwidth]{fig/TemperatuurModuleHTTPCOAPProxy}
\vspace{-30pt}
\caption{Temperatuurmodule met HTTP/COAP-proxy}
\vspace{-10pt}
\end{figure}

\subsubsection{Proxy}
Als proxy werd de coap.me website gebruikt van iMinds. Deze biedt de mogelijkheid om notificaties van een embedded device te bekijken in een browser. De website biedt ook de mogelijkheid om door te klikken naar de notificatie om die volledig te bekijken op een pagina.\\

Het is deze laatste pagina die periodiek wordt opgehaald en geparsed. De communicatie vanwege de Drupal-module bestaat dus enkel uit HTTP-communicatie, de proxy verzorgt de nodige CoAP-berichten tussen zichzelf en het embedded device.

\subsubsection{Polling}
In deze eerste versie van de module bestond het antwoord bij de polling uit de volgende velden:
\begin{itemize}
\item Hid: De History ID dat een numeriek ID is voor de opgevraagde waarde. Het is tevens de index in de databanktabel met waarden en is dus uniek.
\item Temperatuur: Dit is de effectieve waarde in graden Celsius. Deze werd geparsed uit de responsestring afkomstig van de resource.
\item Max-age: De antwoorden van de betreffende resource bevatten een Max-age optie. Dit is het aantal seconden dat deze waarde als geldig mag beschouwd worden.
\item Timestamp: Het tijdstip waarop de waarde ontvangen werd.
\end{itemize}

\subsection{Temperatuurmodule met native CoAP}
Nu de omliggende structuur opgezet en uitgetest is, kan de communicatie veranderen van HTTP-berichten naar native CoAP. Er is in deze versie echter nog geen sprake van de CoAP library. Deze versie beperkt zich tot een eerste test met CoAP-communicatie.\\

Voor CoAP-verkeer zal UDP gebruikt worden zoals voorgeschreven in de CoAP draft \cite{coapDraft}. Eerst wordt een UDP-socket geopend naar het betreffende IPv6-adres van het embedded device waarop de resource is aangesloten. Dit gebeurt met de functie pfsockopen() van PHP, deze opent een persistente socket. Vervolgens wordt een hexadecimale string opgesteld die het bericht voorstelt. Ook deze opstelling gebeurt aan de hand van de CoAP draft \cite{coapDraft}. Het bericht wordt verstuurd met de fwrite() functie. Hierna kan het antwoord opgehaald worden van de socket met de fread() functie die als enige parameter een grootte in bytes heeft. Belangrijk hierbij is dat de opgegeven grootte minstens even groot is als het aantal byets van het volledige antwoord.\\

\subsubsection{Observe}
Nu er gebruik gemaakt wordt van native CoAP, is er ook een echte CoAP observe mogelijk. Hierbij is het noodzakelijk dat de socket opengehouden wordt. Dit omdat het embedded device nu op eigen initiatief berichten kan sturen. Aangezien de socket moet worden opengehouden, kan de code niet meer op de voorgrond draaien. Indien dit wel zo zou zijn, zou de pagina nooit gerenderd worden. De gebruiker zou dan geconfronteerd worden met een timeout van de webserver waarop Drupal draait. Achtergrondprocessen zijn nu dus geen optie meer, maar een noodzaak. De code om een socket open te houden en te beheren zal dus opgestart worden in een achtergrondproces aan de hand van de Background Process module die eerder al vermeld werd \cite{backgroundProcessModule}.\\
Bij ontvangst van een notificatie van de CoAP resource zal de waarde in de databank worden gestopt met bijbehorende velden. Deze velden zijn dezelfde als in de vorige versie van de module (Zie paragraaf \ref{proxy}). Het zijn deze waarden waarop de client met jQuery zal pollen. Ook deze polling gebeurt op dezelfde manier als in de vorige versie van de module.

\subsection{CoAP Sensor module met externe CoAP library}
Alle code die te maken had met CoAP-communicatie was hardgecodeerde code wat onvermijdelijk leidde tot duplicatie van code. Bovendien bevond deze code zich in dezelfde module als diegene die nu wordt besproken. Dit heeft als gevolg dat andere gebruikers van Drupal geen gebruik kunnen maken van onze code om CoAP berichten te sturen en te ontvangen. Dit alles heeft geleid tot de ontwikkeling van onze eigen CoAP library in PHP onder de vorm van een externe module die apart kan worden gebruikt. Deze library werd eerder al besproken in hoofdstuk \ref{coaplibrary}.\\

\subsubsection{Nieuwe block}
De module onderging in deze stap naast een visuele verbetering, ook een verbetering van functionaliteit (Zie figuur \ref{fig:meerdereResources}). Zo kan de gebruiker nu met \'{e}\'{e}n block meerdere resources bevragen.\\

De gebruiker kan \'{e}\'{e}n resource selecteren met radiobuttons, wanneer de gebruiker dan op de knop 'Bekijken' klikt, wordt de pagina herladen en is de geselecteerde resource te bevragen. Door op de knop 'GET' te klikken, wordt een GET-request uitgevoerd op de geselecteerde resource.\\
Er wordt ook een lijst met checkboxes ter beschikking gesteld. De gebruiker kan hierbij de resources aanvinken waarop een observe moet worden uitgevoerd. Wanneer de gebruiker een aangevinkte checkbox uitvinkt, zal de observe stoppen. De instellingen worden opgeslagen en de benodigde acties worden uitgevoerd wanneer de gebruiker op de knop 'Observe' klikt. Belangrijk hierbij is dat wanneer de pagina herladen wordt, de juiste checkboxes al worden aangevinkt zodat de gebruiker ten allen tijde weet welke resources al geobserveerd worden.\\
Een laatste verbetering bestaat uit een grafiek die automatisch wordt gegenereerd op basis van de geschiedenis van opvragingen. De grafiek wordt aan de hand van een AJAX call en de Google Charts API \cite{googleCharts} gerealiseerd. Het betreft hier de waarden van de resource die momenteel bekeken wordt en dus aangeduid is met een radiobutton.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/meerdere_resources}
\caption{Block met HTML-formulieren die de gebruiker toelaat meerdere resources met \'{e}\'{e}n block te bevragen.}
\label{fig:meerdereResources}
\end{figure}

\subsection{CoAP Sensor module met content type CoAP Resource}
In de vorige versies werd de module weergegeven aan de hand van een HTML-formulier in een Drupal-block. Het nadeel hiervan is dat men standaard slechts \'{e}\'{e}n instantie van het block gebruikt. Men kan echter wel het een en het ander verbeteren met de Views module, maar het is niet de bedoeling dat wij dit verlangen van de gebruiker. Bovendien is een block slechts een visuele blok op de website, het is niet echt een node of een stuk content.\\

Een beter en vaak gebruikt alternatief is het maken van een eigen content type. Wanneer men nu deze module installeert worden de content types gedefin\"{i}eerd in de module mee ge\"{i}nstalleerd. Dit heeft als gevolg dat de gebruiker slechts op 'Add content' hoeft te klikken (Zie figuur \ref{fig:addContent}), enkele benodigde velden in moet vullen en de content wordt automatisch gegenereerd en opgeslagen. Bij deze methode wordt al deze configuratie afgehandeld door Drupal-mechanismen, zo worden bijvoorbeeld de velden opgeslagen in tabellen die behoren tot de Drupal core. Dit betekent dat onze content effectief wordt ingepast en geen losstaand geheel is. Het beheer van de content, manipulatie en dergelijke zal dus gebeuren met Drupal zoals dat gebeurt voor andere content types. We merken ook op dat wanneer een resource verwijderd wordt, dit niet het geval is voor de waarden die ervan opgehaald zijn. Deze blijven aanwezig in de databank en zullen ook weer te zien zijn wanneer de resource later opnieuw wordt toegevoegd.\\

\subsection{CoAP resource met volledige REST functionaliteit} \label{rest}
Tot nog toe was enkel een GET-request mogelijk naar een resource, maar vaak ondersteunt een resource ook nog andere REST methodes (GET, PUT, POST, DELETE). Het is dus van groot belang dat onze module ook de mogelijkheid biedt om alle REST methodes uit te voeren.\\

Dit brengt ook mee dat de visuele representatie zal wijzigen (Zie figuur \ref{fig:rest}). De vier methodes worden met knoppen weergegeven in een tabel, eventueel vergezeld van een tekstveld indien invoer vereist is (PUT en POST). Onderaan de tabel wordt de response en response method (205 Content, 405 Bad method,...) getoond .\\
Wij hebben ervoor gekozen dat de gebruiker voor elke resource, op elk moment elke REST methode kan uitvoeren. Er wordt namelijk al een gepaste response getoond wanneer een methode niet ondersteund is. Bovendien is een server niet verplicht in een resource discovery (Zie paragraaf \ref{resourceDiscovery}) aan te geven welke methodes ondersteund zijn. Wil men voor elke resource toch methodes uitschakelen die niet ondersteund zijn, dan zou men elke methode eens moeten uitproberen en verif\"{i}eren of een 405 Bad Request teruggestuurd wordt.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/rest}
\caption{CoAP resource met volledige REST functionaliteit.}
\label{fig:rest}
\end{figure}

\subsection{CoAP Sensor module met resource discovery}
De gebruiker is nu in staat meerdere CoAP resources toe te voegen aan zijn/haar website. Het kan echter moeilijk zijn een overzicht te behouden over al deze resources en bovendien moet men van elke resource de specifieke URI kennen, wat zeker niet vanzelfsprekend is.\\

Deze nadelen kunnen worden weggewerkt door gebruik te maken van resource discovery. De technische uitleg en implementatiedetails werden al besproken in paragraaf \ref{resourceDiscovery}. In deze module krijgt de gebruiker na het uitoveren van een resource discovery, een lijst van CoAP resources te zien die aangesloten zijn op het embedded device. Om performantieredenen en omwille van het feit dat een well-known/core weinig of nooit verandert, wordt het resultaat van de resource discovery (Zie paragraaf \ref{resourceDiscovery}) opgeslagen in de databank. De manier waarop de gegevens opgeslaan zijn is dezelfde als in het eindresultaat en wordt besproken in \ref{databankSchema}. Er wordt echter op de website wel nog een Refresh-knop voorzien mocht de gebruiker de gegevens in de databank toch willen vernieuwen.\\
Op de website wordt een resource weergegeven door de URI en door de human readable name. Bovendien is voor elke resource ook een checkbox voorzien om aan te duiden dat de gebruiker ge\"{i}nteresseerd is in de resource. De gekozen resources worden dan opgesomd en ter beschikking gesteld op dezelfde manier als in de vorige versie van de module (Zie figuur \ref{fig:meerdereResources}). In de volgende twee subparagrafen bespreken we twee mogelijke vormen die wij gemaakt hebben om de resource discovery en opsomming van de resources te combineren.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/tabbladen}
\caption{Opsomming van resources aan de hand van resource discovery.}
\label{fig:tabbladen}
\end{figure}

\subsubsection{Multi-form}
Een eerste mogelijkheid bestaat erin eerst de lijst te presenteren aan de gebruiker. De gebruiker kiest dan een aantal resources die hij/zij wil toevoegen aan de website, waarna hij/zij op de knop 'Save' klikt. Hierna wordt een nieuwe pagina getoond die de gebruiker toelaat de resources te beheren en te bevragen (Zie figuur \ref{fig:meerdereResources}). De gebruiker kan altijd terugkeren naar het discoveryformulier om de resource discovery opnieuw uit te voeren of resources te selecteren/deselecteren. Dit gebeurt wanneer hij op een knop met opschrift 'Back' onderaan het formulier klikt. Wanneer op Save of Back geklikt wordt, wordt het formulier ingediend. In de submit handlers van de knoppen worden gegevens verwerkt en wordt het juiste formulier getoond.

\subsubsection{Tabbladen}
De tweede mogelijkheid bestaat uit een pagina met tabbladen. Op deze manier kan de gebruiker gemakkelijker navigeren tussen de verschillende formulieren en hoeven deze niet steeds ingediend te worden. Er zijn 3 tabbladen voorzien (Zie figuur \ref{fig:tabbladen}):
\begin{itemize}
\item Resources: Dit tabblad bestaat uit het block dat de gebruiker in staat stelt de resources te beheren en te bevragen zoals in de vorige versie van de module (Zie figuur \ref{fig:meerdereResources}).
\item Discovery: Dit tabblad toont de lijst van resources met bijbehorende checkbox (Zie figuur \ref{fig:tabbladen}).
\item Configuration: Dit tabblad is voorzien voor een configuratie die door de gebruiker kan worden ingesteld. Deze is echter niet ge\"{i}mplementeerd in deze module, maar kan wel toegevoegd worden in verder ontwerp (Zie paragraaf \ref{configuratie}).
\end{itemize}

\subsection{CoAP Sensor module met meerdere content types}
Dit is de, voor ons laatse, versie van de module die uitgebreid in dit hoofdstuk besproken wordt. Hier wordt nog een groot nadeel dat de kop opsteekt weggewerkt. De gebruiker was niet in staat een aparte resource toe te voegen zonder dat de functionaliteit van resource discovery erbij kwam. We lossen dit op door meerdere content types in te voeren.

\section{Databankmanipulatie}

\subsection{Content type in de databank}\label{databankSchema}
Onder content-type van de databank verstaan we de definitie van nodige databanktabellen en -kolommen. Er moet namelijk heel wat data opgeslagen worden waaronder de verschillende resources, de relatie tussen resources/devices en users en de opgehaalde waarden.\\

Zoals eerder vermeld worden de tabellen aangemaakt bij installatie van de module. Dit wordt mogelijk gemaakt door gebruik te maken van hook\_schema(). In deze hook wordt het databankschema opgesteld en teruggegeven als array door de functie. Bij de\"{i}nstallatie worden de tabellen verwijderd uit de databank. Dit gebeurt door gebruik te maken van hook\_uninstall() door gebruik te maken van de functie db\_drop\_table().\\

\noindent
Er worden drie tabellen ge\"{i}mplementeerd (Zie figuur \ref{fig:databankModel}), welke beschreven worden in de komende paragrafen.
\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/databankModel}
\caption{EER-diagram van de door ons toegevoegde tabellen.}
\label{fig:databankModel}
\end{figure}

\subsubsection{coap\_sensor\_resource}
De tabel bevat informatie over CoAP-resources die toegevoegd werden aan de site. Hij bevat volgende kolommen (Zie figuur \ref{fig:databankModel}):
\begin{itemize}
\item uri: Dit is de volledige URI van de resource, dus IPv6-adres en URI-path. Dit is tevens de primaire sleutel van deze kolom, elke waarde moet dus uniek zijn.
\item obs, rt, ct, ifd, sz, title, anchor en rel: Deze kolommen bevatten waarden die bekomen worden bij resource disovery. Deze werden eerder uitgelegd in paragraaf \ref{resourceDiscovery}.
\item last\_error: Deze kolom bevat voor elke resource de laatst opgetreden fout. Zo kan een browser te weten komen bij polling dat er iets foutliep bij communicatie met de betreffende resource.
\item created: De UNIX timestamp van de tijd waarop deze resource aangemaakt werd.
\item changed: De UNIX timestamp van de tijd waarop deze resource het laatst gewijzigd werd.
\item not\_in\_core: Een waarde om aan te geven of deze resource nog in de well-known/core zit van een device.
\end{itemize}
\subsubsection{coap\_sensor\_interested\_user}
In deze tabel wordt bijgehouden welke users ge\"{i}nteresseerd zijn in specifieke resources en devices. Hij bevat een entry voor elk koppel user/resource en user/device en wordt impliciet geassoc\"{i}eerd met een instantie van respectievelijk coap\_resource of coap\_device. Op die manier kan per user worden bijgehouden wat hij/zij met een bepaalde resource wil doen. Ze bestaat uit de volgende kolommen:
\begin{itemize}
\item uid: Een unieke identificatie voor een gebruiker. Dit ID is overgenomen uit Drupal, daar hebben alle gebruikers ook een uniek User ID. Deze kolom is tevens deel van de primaire sleutel.
\item uri: De URI van de resource waarin de gebruiker ge\"{i}nteresseerd is. Dit is dezelfde URI als in de vorige tabel (coap\_resource\_resources). Deze kolom vormt dus een foreign key en maakt tevens deel uit van de primaire sleutel.
\item nid: Een unieke identificatie van de node (Node ID)\nomenclature{nid}{Node ID} waaraan de resource gekoppeld is in Drupal. Deze kolom is ook deel van de primaire sleutel.
\item device: Deze waarde geeft aan of het een resource of een volledig embedded device betreft (0 = resource, 1 = device).
\item observe: Deze waarde geeft aan of de gebruiker momenteel de resource wil observeren of niet (0 = niet observeren, 1 = wel observeren).
\item polling\_interval: Dit is de periode in seconden tussen twee polls van de browser naar de Drupal-server, deze is default drie seconden.
\item new: Deze waarde duidt aan of er inmiddels een nieuwe discovery is uitgevoerd of bezig is voor een device. Deze waarde heeft momenteel enkel voor devices. (0 = up-to-date, 1 = discovery bezig, 2 = discovery klaar)
\end{itemize}
De primaire sleutel bestaat uit de combinatie van de kolommen uid, uri en nid. Elke combinatie van waarden uit deze drie kolommen moet per entry uniek zijn.

\subsubsection{coap\_sensor\_value}
Deze tabel bevat een entry voor elke waarde die is binnengekomen. Bovendien wordt een nieuwe waarde even veel keren toegevoegd als er ge\"{i}nteresseerden zijn voor die waarde op dat moment. Dit lijkt op het eerste zicht redundante informatie, maar het heeft wel degelijk nut. Zo kan men bijvoorbeeld later te weten komen voor een bepaalde user, welke waarden hij/zij in welke periode heeft opgevraagd. De tabel bevat de volgende kolommen:
\begin{itemize}
\item hid: Een uniek ID voor de entry automatisch gegenereerd bij toevoegen aan de databank. Dit is de primaire sleutel, dus deze waarden moeten uniek zijn.
\item uid: Het ID van de user waarvoor deze waarde opgeslagen is. Dit is hetzelfde ID als in de coap\_resource\_users-tabel en vormt dus een foreign key.
\item uri: De URI van de resource waarvan deze waarde komt. Dit is dezelfde URI als in de coap\_resource\_resources-tabel en vormt dus een foreign key.
\item content\_format: Bevat voor elke entry het formaat van het bericht, aangeduidt met een leesbare naam (bijvoorbeeld plain text, JSON, ...). 
\item payload: De payload van het bericht in leesbare vorm.
\item parsed\_value: Indien mogelijk bevat dit een waarde die geparset is uit de payload, bijvoorbeeld een numerieke waarde. Indien er geen waarde kon geparset worden bevat deze kolom gewoon de payload.
\item max\_age: Geeft aan wat de geldigheidsduur is voor deze waarde, deze is default nul.
\item timestamp: Het tijdstip waarop de waarde in de databank werd opgeslagen in mysql timestamp-formaat. Deze wordt automatisch gegenereerd. Samen met de max-age kan men dus bepalen of de waarde nog geldig is.
\item original\_response: De originele response op het CoAP request-bericht in hexadecimale vorm.
\item new: Geeft aan of de waarde reeds opgehaald werd om te tonen aan de gebruiker (0 = reeds afgehaald, 1 = nog niet afgehaald, default waarde = 0).
\end{itemize}

\subsection{Database Abstraction Layer}
Manipulatie van gegevens in de databank gebeurt via de Database Abstraction Layer \cite{databaseAbstractionLayer}. Dit zorgt ervoor dat de implemenatie van een module onafhankelijk is van de gebruikte soort databank. Concreet biedt deze laag een aantal functies aan voor het manipuleren van de databank. Wanneer een nieuwe soort databank in gebruik genomen wordt, worden deze functies ge\"{i}mplementeerd voor deze nieuwe soort. We geven enkele voorbeelden van de meest gebruikte functies:
\lstset{language=PHP}
\begin{lstlisting}[label=db_select,caption=Voorbeeld gebruik van db\_select]
$result = db_select('coap_sensor_interested_user','resource')
	->fields('resource', array('nid'))
	->condition('uri', $uri, '=')
	->condition('uid', $user->uid, '=')
	->execute();
\end{lstlisting}
In voorbeeld \ref{db_select} wordt opgevraagd wat het nid is voor een specifieke uri en uid. Er wordt gebruik gemaakt van de Drupal-variabele \$user. Zoals je ziet moet er een naam opgegeven worden na de tabelnaam. Deze naam moet herhaalt worden als eerste element van de fields array. Merk op dat dit alleen nodig is bij het gebruik van db\_select. Als tweede element van de fields array geef je een array op met alle velden die je wil opvragen. Meerdere condities kunnen opgegeven worden, de volgorde is niet belangrijk. De opgevraagde gegevens kunnen gesorteerd worden door gebruik te maken van -\textgreater orderBy('nid', 'ASC').\\

De variabele \$result zal een SelectQuery-object bevatten. Er zijn twee manieren om de opgehaalde gegevens uit objecten van deze klasse te halen. Wanneer je weet dat er maar een enkele rij opgehaald wordt, doe je best het volgende
\lstset{language=PHP}
\begin{lstlisting}
$record  = $result->fetchAssoc();
$nid = $record['nid'];
\end{lstlisting} 
Wanneer er meerdere rijen teruggegeven kunnen worden gebruik je beter
\lstset{language=PHP}
\begin{lstlisting}
$nids = array();
foreach($result as $record){
	array_push($nids,$record->nid);
}
\end{lstlisting} 
om een array met al je gewenste resultaten in te bekomen. In dit voorbeeld zal er echter maar \'{e}\'{e}n rij teruggegeven worden en is de eerste optie beter.
\lstset{language=PHP}
\begin{lstlisting}[label=db_insert,caption=Voorbeeld gebruik van db\_insert]
$id = db_insert('coap_sensor_interested_user')
	->fields(array(
		'uid' => $user->uid,
		'uri' => $resource_uri,
		'device' => 0,
		'nid' => $nid,
		'observe' => 0,
	))
	->execute();
\end{lstlisting}
In voorbeeld \ref{db_insert} wordt een entry toegevoegd aan de tabel coap\_sensor\_interested\_user. Kolommen die niet null mogen zijn en geen default waarde hebben moeten opgegeven worden in de fields array. Zoniet wordt er een exceptie opgegooid bij het oproepen van de execute-functie.

\lstset{language=PHP}
\begin{lstlisting}[label=db_update,caption=Voorbeeld gebruik van db\_update]
$num_updated = db_update('coap_sensor_interested_user')
	->fields(array(
		'new' => 0,
	))
	->condition('uid', $user->uid, '=')
	->condition('device',1,'=')
	->condition('nid', $nid, '=')
	->execute();
\end{lstlisting}
In voorbeeld \ref{db_update} wordt van alle rijen die overeenstemmen met de opgegeven condities de new-waarde op 0 gezet. Bij dit voorbeeld zal er maar \'{e}\'{e}n rij geupdated worden.

\lstset{language=PHP}
\begin{lstlisting}[label=db_delete,caption=Voorbeeld gebruik van db\_delete]
db_delete('coap_sensor_interested_user')
	->condition('nid', $nid, '=')
	->execute();
\end{lstlisting}
In voorbeeld \ref{db_delete} worden alle rijen met als nid de waarde in \$nid verwijderd. Opnieuw zal in dit voorbeeld maar \'{e}\'{e}n rij verwijderd worden.

\section{Content types in Drupal}

Bij installatie van de module worden twee content types mee ge\"{i}nstalleerd. We bespreken wat de mogelijkheden ervan zijn en hoe ze eruitzien. Het laten installeren van content types zorgt ervoor dat een Drupal-gebruiker op een eenvoudige manier content kan toevoegen, in dit geval onderdelen van een CoAP-sensornetwerk. Concreet moet de gebruiker enkel op 'Add content' klikken op zijn/haar Drupal-website en het gewenste content type aanklikken. Na invullen van enkele vereiste velden wordt een node gecre\"{e}erd die de content voorstelt.
\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/add_content}
\caption{Content toevoegen door op 'Add content' te klikken.}
\label{fig:addContent}
\end{figure}

\subsection{CoAP Resource}
\begin{wrapfigure}{r}{0.6\textwidth}
\vspace{-10pt}
%\hspace{-10pt}
\centering
\label{fig:addCoapResource}
\includegraphics[width=0.6\textwidth]{fig/add_coap_resource}
\vspace{-20pt}
%\hspace{-10pt}
\centering
\caption{Adding content of content type CoAP resource}
\centering
\vspace{-20pt}
\end{wrapfigure}
Dit content type stelt \'{e}\'{e}n resource voor. Bij het toevoegen wordt de URI opgegeven, deze bestaat uit het IPv6-adres van het embedded device waarop de resource is aangesloten en een URI-path. IPv6-adres en URI-path worden gescheiden door een slash ('/'). Een voorbeeld van een door ons vaak gebruikte URI is: 2001:6a8:1d80:200::2/test.\\
Vooraf een resource effectief toegevoegd wordt, wordt hij gevalideerd. We voegen custom validatie toe via hook\_form\_alter. Indien de structuur van de URI niet geldig is of de resource al eerder door de gebruiker is toegevoegd, wordt er een foutmelding getoond en krijgt de gebruiker opnieuw de kans om een geldige/andere URI op te geven. Na een succesvolle validatie, wordt er content van het type coap\_resource toegevoegd. Door middel van hook\_node\_insert worden er enkele dingen in de databank toegevoegd. Er wordt een entry in de tabel coap\_sensor\_interested\_user toegevoegd waarmee wordt aangegeven dat de gebruiker die de resource toevoegde ge\"{i}nteresseerd is in de resource. Er wordt ook gekeken of er voor deze resource informatie beschikbaar is in de tabel coap\_sensor\_resource. Indien dit niet het geval is wordt een parti\"{e}le resource discovery uitgevoerd door middel van query filtering. Indien er wel informatie beschikbaar is moet er niets meer gebeuren en krijgt de gebruiker de visuele representatie van de content te zien.\\

De gebruiker krijgt nu de kans om de REST-methodes  GET, PUT, POST en DELETE uit te voeren en een observe. Bovendien krijgt de gebruiker een geschiedenis van opvragingen voor deze resource te zien en krijgt hij ook de kans een grafiek te laten genereren. Voor het type grafiek heeft de gebruiker de keuze uit een lijn-, staaf-, of taartgrafiek. De gebruiker moet zelf weten welke soort grafiek nuttige informatie kan bevatten.
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{fig/coap_resource}
\caption{Visuele representatie van het content type CoAP resource.}
\label{fig:coapResource}
\end{figure}
De visualisatie wordt verzorgd door middel van een template wat besproken wordt in \ref{templating}. Het pollingmechanisme is aangepast op een manier dat besproken wordt in \ref{polling}.

\subsubsection{Templating}\label{templating}
Nu de functionaliteit min of meer op punt staat, wordt het tijd voor visuele opmaak. En dit op een manier die aangeraden wordt door de Drupal community, waarbij de view netjes gescheiden wordt. Concreet maken we een template voor het content-type CoAP resource. Drupal voorziet hier een handig mechanisme voor, men kan namelijk een template maken voor een specifiek content-type. Het enige wat men moet doen om ervoor te zorgen dat die template automatisch wordt opgeroepen voor het content-type, is het template-bestand de juiste naam geven. Drupal voorziet namelijk in alle themes een standaard template voor een node, namelijk node.tpl.php. Om nu onze template te defini\"{e}ren, moet deze de naam node--coap\_resource.tpl.php dragen, daar de naam van ons content-type coap\_resource is.\\

Het voordeel van deze benadering is dat men in dit bestand HyperText Markup Language (HTML) \nomenclature{HTML}{HyperText Markup Language} kan schrijven. Wanneer men bepaalde attributen of content nodig heeft voor de visuele representatie, kan men die variabelen voorzien door gebruik te maken van de hook hook\_preprocess\_node(). Deze hook wordt op voorhand opgeroepen en variabelen worden klaargezet. In het template-bestand kan men deze variabelen bereiken aan de hand van PHP-scriptlets (Zie listing \ref{template}). Men kan in deze templates dus ook PHP-code laten uitvoeren, al beperkt men dit best tot een minimum om de view gescheiden te houden. Concreet worden bij ons de URI van de resource en enkele waarden gebruikt in het template-bestand.\\

Er stelt zich nu wel nog een probleem, het template-bestand moet namelijk op de juiste plaats staan, en dit in de directory van het gebruikte theme. Men voegt echter beter geen bestanden toe aan de Drupal core en bovendien kunnen wij dat ook niet verwachten van de eindgebruiker. Het template-bestand zou automatisch moeten worden opgenomen in het gebruikte theme, waarbij het template-bestand gewoon in onze module kan blijven staan. Na grondig onderzoek bleek dit mogelijk aan de hand van een hook, namelijk de hook hook\_theme\_registry\_alter(). Die geeft ons de kans een pad toe te voegen aan het theme-registry, waardoor het template zal gevonden worden bij het bouwen van de view \cite{addTemplate}.

\lstset{language=HTML}

\begin{lstlisting}[label=template,caption=Voorbeeld van een template met PHP-scriptlets (node.tpl.php)]
<div id='node-<?php print $node->nid; ?>' >
	<?php print render($title_prefix); ?>
	<?php if (!$page): ?>
	<h2<?php print $title_attributes; ?>>
		<a href='<?php print $node_url; ?>'>
			<?php print $title; ?>
		</a>
	</h2>
	<?php endif; ?>
	<?php print render($title_suffix); ?>
</div>
\end{lstlisting}

\subsubsection{Polling}\label{polling}
In vorige versies van de module had de gebruiker niet de kans om meerdere resources op \'{e}\'{e}n pagina te zetten met de Views module. Dit was in principe wel mogelijk, maar er zouden fouten optreden daar de polling gebeurde op basis van welke resource geselecteerd was. Dit selecteren van resources is in deze versie weggewerkt, elke resource is een op zichzelf staand geheel (Zie figuur \ref{fig:coapResource}). In deze versie is dit wel mogelijk omdat het polling mechanisme grondig werd aangepast zoals nu zal blijken.\\

Een poll gebeurt nu specifiek voor een URI die opgegeven wordt in de URL waarnaar een AJAX call wordt uitgevoerd. Bovendien werd in de databank een extra kolom 'New' toegevoegd aan de waardentabel. Deze duidt aan of een waarde reeds is opgehaald of nog niet (0 = reeds opgehaald, 1 = nog niet opgehaald). De kolom heeft als default waarde 1, dus nieuwe waarden worden automatisch als nieuw aangeduid. Wanneer een waarde opgehaald wordt uit de databank wordt de waarde in de kolom 'New' op 0 gezet.\\
Het pollen naar waarden voor een specifieke URI gebeurt nu als volgt:
\begin{itemize}
\item Er wordt in jQuery een AJAX call uitgevoerd naar een bepaalde URL, bijvoorbeeld http://localhost/coap\_resource/poll/2001:6a8:1d80:200::2\textbar test. In de URI wordt een slash vervangen door een rechte streep ('\textbar'), anders wordt de slash ge\"{i}nterpreteerd.
\item Op de webserver wordt in Drupal de URI uit de aanvraag-URL gehaald en worden de slashes terug geplaatst.
\item De URI wordt gebruikt in een select-query om de nog niet opgehaalde waarden op te halen, dit wil zeggen de rijen waarvan de waarde in de kolom 'New' op 1 staat.
\item Er wordt een update-query uitgevoerd om van de opgehaalde rijen de waarde in de kolom 'New' te wijzigen naar 0. Dit om aan te geven dat de waarden reeds opgehaald werden.
\item De opgehaalde rijen worden in een XML-structuur gegoten samen met identificatie van de resource (de URI) en een eventuele errorstring. Deze XML-structuur wordt na deze stappen toegelicht.
\item De XML-structuur wordt uitgeprint en dus teruggestuurd als antwoord op de AJAX call.
\item in jQuery wordt dan het antwoord geparsed. De errorstring wordt eruit gehaald en eventuele fouten worden getoond aan de gebruiker (Zie paragraaf \ref{foutmechanisme}). Daarna wordt elke opgehaalde rij \'{e}\'{e}n voor \'{e}\'{e}n overlopen en toegevoegd aan de visuele content die de gebruiker ziet.
\end{itemize}

De XML-structuur die eerder werd aangehaald bestaat uit een allesomvattend hoofdelement \textless poll\textgreater. Dit element bevat 3 andere soorten elementen:
\begin{itemize}
\item \textless uri\textgreater: Dit element komt \'{e}\'{e}n keer voor, het bevat de URI en dus de identificatie van de resource.
\item \textless error\textgreater: Net als het vorige element komt dit element ook \'{e}\'{e}n keer voor, het bevat de eventuele errorstring. Deze kan \'{e}\'{e}n van de volgende zijn: none, delay, broken of unreachable.
\item \textless entry\textgreater: Dit element stelt een rij voor met een waarde. Dit element kan dus nul of meer keren voorkomen. Het bestaat zelf uit de volgende elementen:
\begin{itemize}
\item \textless Hid\textgreater: de history ID van de rij.
\item \textless Value\textgreater: de effectieve (eventueel geparsete) waarde van de rij.
\item \textless Max age\textgreater: Het aantal seconden dat deze waarde als geldig mag worden beschouwd.
\item \textless Timestamp\textgreater: Het tijdstip waarop de waarde ontvangen werd op de Drupal-server.
\end{itemize}
\end{itemize}

Een voorbeeld van een antwoord op een AJAX call bij polling:

\lstset{language=XML}

\begin{lstlisting}[label=xmlPolling,caption=Voorbeeld antwoord op AJAX call bij polling]
<poll>
	<uri>2001:6a8:1d80:200::2</uri>
	<error>none</error>
	<entrys>
		<entry>
			<hid>76</hid>
			<value>20.2</value>
			<max_age>30</max_age>
			<timestamp>2013-05-20 20:36:32</timestamp>
		</entry>
		<entry>
			<hid>77</hid>
			<value>20.4</value>
			<max_age>30</max_age>
			<timestamp>2013-05-20 20:36:37</timestamp>
		</entry>
	</entrys>
</poll>
\end{lstlisting}

\subsubsection{Foutmechanisme} \label{foutmechanisme}
Tot nog toe bleef de gebruiker in het ongewisse wanneer er iets foutliep in de communicatie met een CoAP resource. Dit is niet gebruiksvriendelijk en kan voor ergernissen zorgen.\\
Nu hebben we in de vorige hoofdstukken al gezien dat fouten al geregistreerd worden aan de hand van enkele errorstrings. Deze zijn zelfs al ter beschikking in jQuery bij elke poll (Zie polling hierboven). Het enige wat nu nog moet gebeuren is een gepaste boodschap tonen in de visuele representatie. Zoals te zien in figuur \ref{fig:foutmechanisme} wordt in het groen een vinkje getoond wanneer een operatie geslaagd is. Wanneer de communicatie niet gelukt of foutgelopen is wordt de methode geannuleerd en wordt een kruisje in het rood getoond. Ook wanneer een methode niet ondersteund is, wordt dit kruisje getoond. Wanneer het antwoord op zich laat wachten worden roterende blauwe pijltjes getoond.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/foutmechanisme}
\caption{Mechanisme om fouten te tonen aan de gebruiker.}
\label{fig:foutmechanisme}
\end{figure}

\subsection{CoAP Device}
\begin{wrapfigure}{r}{0.6\textwidth}
\vspace{-10pt}
%\hspace{-10pt}
\centering
\label{fig:addCoapDevice}
\includegraphics[width=0.6\textwidth]{fig/add_coap_device}
\vspace{-20pt}
%\hspace{-10pt}
\centering
\caption{Adding content of content type CoAP device}
\centering
\vspace{-20pt}
\end{wrapfigure}
Dit content type stelt een volledig embedded device voor waarop \'{e}\'{e}n of meerdere resources zich bevinden. Bij toevoegen van dit content type hoeft de gebruiker enkel het IPv6-adres op te geven. Aan de hand van resource discovery wordt dan een lijst van aangesloten resources opgebouwd en getoond aan de gebruiker. Nu kan de gebruiker doorklikken naar een resource die voorgesteld wordt aan de hand van het content type CoAP resource beschreven in de vorige subparagraaf.
\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{fig/coap_device}
\caption{Visuele representatie van het content type CoAP device.}
\label{fig:coapDevice}
\end{figure}

%hier moet alles komen
%it wordt gerealiseerd met de al eerder behandelde content types. Er worden nu twee content types gecre\"{e}erd bij installatie van de module, \'{e}\'{e}n voor een CoAP resource (Zie figuur \ref{fig:coapResource}) en \'{e}\'{e}n voor een CoAP device (Zie figuur \ref{fig:coapDevice}).\\

%Wanneer een CoAP device wordt toegevoegd door de gebruiker, wordt er automatisch een resource discovery op uitgevoerd. De gebruiker krijgt dan een lijst van links te zien, \'{e}\'{e}n link per aangesloten CoAP resource (Zie figuur \ref{fig:coapDevice}). Bovendien wordt voor elk van die resources content aangemaakt van het content type CoAP resource. De gebruiker zal geen 2 gelijke resources kunnen toevoegen om duplicatie van content te vermijden. Wanneer de gebruiker toch dezelfde resource op verschillende plaatsen van de website wil krijgen, raden wij aan de Views module te gebruiken \cite{viewsModule}. Met Views kan men meerdere visuele representaties maken van dezelfde content, dus zonder content te dupliceren.

\subsection{Installatie content types}
Voor we uitleggen hoe de content types ge\"{i}nstalleerd en gede\"{i}nstalleerd worden, merken we op dat er naast de\"{i}nstalleren van een module ook disablen mogelijk is. Dit kan als gevolg hebben dat een beginnende Drupal-ontwikkelaar enkele dingen over het hoofd ziet. We maken een opsomming van handige feiten in verband met enablen, disablen en de\"{i}nstalleren voor beginnende Drupal-ontwikkelaars:
\begin{itemize}
\item Bij disablen wordt hook\_disable() opgeroepen. Dit is analoog voor enablen, installeren en de\"{i}nstalleren.
\item Een gebruiker moet een module altijd eerst disablen voor te de\"{i}nstalleren.
\item Een gebruiker kan een module enkel enablen, disablen of de\"{i}nstalleren. Een module wordt ge\"{i}nstalleerd als ze voor de eerste keer enabled wordt of eerst gede\"{i}nstalleerd werd voor te re-enablen.
\item Sommige hooks worden maar opgeroepen bij installatie van de module, wat betekent dat wanneer je een wijziging van deze hooks wil doorvoeren, je de module moet disablen, de\"{i}nstalleren en re-enablen. De\"{i}nstallatie mag niet worden overgeslagen omdat de module dan niet geherinstalleerd wordt. Dit is van toepassing bij volgende hooks:
\begin{itemize}
\item hook\_node\_info()
\item hook\_schema()
\end{itemize}
\end{itemize}

Er zijn meerdere manieren om content types te installeren en configureren.
\begin{itemize}
\item De functie node\_type\_save() gebruiken om een nieuw type zelf op te slaan.
\item Hook\_node\_info() gebruiken waarin je de nieuwe content types beschrijft. Deze optie wordt algemeen als de betere optie gezien omdat het gebruik van hooks de Drupal way is.
\end{itemize}
Bij zowel de eerste als de tweede optie zijn nog een zaken nodig om een content type te configureren. Een aantal rijen moeten toegevoegd worden in de variabletabel die standaard ge\"{i}nstalleerd wordt door Drupal. Deze speciale tabel heeft maar twee kolommen, name en value. Deze tabel wordt gemanipuleerd met speciale functies:
\begin{itemize}
\item variable\_get(\$naam): De variabele wordt opgehaald. Een tweede parameter kan opgegeven worden, als de variabele niet in de databank zit wordt deze waarde teruggegeven en wordt de variabele toegevoegd in de databank.
\item variable\_set(\$naam, \$value): De variabele wordt gezet.
\item variable\_del(\$naam): De variabele wordt verwijderd.
\end{itemize}

\noindent
In hook\_enable() worden enkele variabelen gezet. Deze variabelen moeten voor elk content type gezet worden. We degenen op die we gebruiken:
\begin{itemize}
\item comment\_content\_type: Krijgt de waarde 0 om default commentaren uit te schakelen.
\item node\_options\_content\_type: Krijgt de waarde array('status') om default 'Promote to Front page' uit te vinken.
\item node\_preview\_content\_type: Krijgt de waarde 0 om de mogelijkheid tot een preview te disablen.
\item node\_submitted\_content\_type: Krijgt de waarde 1 om default de auteur en de tijd waarop de content is toegevoegd te tonen bij de content zelf.
\end{itemize}
Welke opties beschikbaar zijn vind je hier \cite{contentTypeVariables}.\\

\noindent
De laatste stap bestaat uit het cre\"{e}eren van de velden die toegevoegd gaan worden aan de content types, vervolgens worden er instanties van de velden aangemaakt om ze te linken aan de content types. Dit gebeurt in hook\_install(). De velden worden aangemaakt field\_create\_field(\$field) en de instanties worden aangemaakt met field\_create\_instance(\$instance). Er worden velden aangemaakt voor: de URI van devices, de URI van resources, meerdere referenties naar content van het type coap\_resource.

\subsection{De\"{i}nstallatie content types}
De content types worden verwijderd in hook\_uninstall(). Voor een content type kan verwijderd worden moet nog een aantal andere zaken verwijderd worden. We overlopen de verschillende stappen die voor elk te verwijderen content type moeten overlopen worden:
\begin{itemize}
\item Alle content van het content type wordt verwijderd door middel van de functie node\_delete\_multiple(\$nids). De variabele \$nid bevat een array met alle nids van de content die verwijderd wordt.
\item Alle variabelen die toegevoegd werden in de variabletabel worden verwijderd door gebruik te maken van variable\_del(\$naam);
\item De commententiteit die geassocieerd is met dit content type wordt gemarkeerd om te verwijderen. Hiervoor wordt de functie field\_delete\_instance() gebruikt.
\item Het content type wordt verwijderd met node\_type\_delete(\$type\_name).
\item De databankcache van node types wordt geupdated met node\_types\_rebuild(). Dit is nodig omdat Drupal vaak in caches kijkt en verouderde informatie kan gebruiken.
\item Drupal zal bij het verwijderen van velden de kolomwaarde deleted op 1 zetten. Om de velden effectief uit de databank te verwijderen wordt de functie field\_purge\_batch() gebruikt.
\end{itemize}

\section{Implementatie van de CoAP library-hooks}
In deze paragraaf bekijken we hoe deze module de hooks implementeert die de CoAP library voorziet (Zie paragraaf \ref{observe_hooks}).

\subsection{hook\_receive\_notification()}
Deze hook wordt opgeroepen door de CoAP library wanneer een bericht binnenkomt op de socket. Er wordt een response-object gemaakt van de klass CoAPMessage dat tevens meegegeven wordt als enige attribuut van de hook.\\
In deze module worden in de hook volgende stappen ondernomen:
\begin{itemize}
\item De benodigde waarden worden uit het response-object gehaald en in de databank gestopt voor de huidige gebruiker.
\item De user ID's van alle andere ge\"{i}nteresseerden (dus niet de huidige gebruiker) voor de betreffende resource worden opgehaald uit de databank.
\item Voor elk van deze users worden de waarden uit het response-object ook toegevoegd aan de databank.
\end{itemize}

\subsection{hook\_receive\_error()}
Deze hook wordt voorzien van de volgende parameters: een errorstring, het IPv6-adres van het embedded device en de naam van de resource. Ze wordt opgeroepen wanneer \'{e}\'{e}n van de volgende gebeurtenissen zich voordoet:
\begin{itemize}
\item De socket kon niet worden geopend naar het embedded device. Deze gebeurtenis resulteert in een errorstring gelijk aan 'unreachable'.
\item De tijdsspanne verstrijkt waarin een antwoord zou moeten ontvangen zijn, dit wordt bepaald met het exponential backoff-mechanisme (Zie paragraaf \ref{exponentialBackoff}). Dit levert een errorstring gelijk aan 'delay'.
\item Het maximum aantal pogingen om het bericht opnieuw te versturen is verstreken (Zie paragraaf \ref{exponentialBackoff}). Nu zal de errorstring gelijk zijn aan 'broken'.
\item Ook wanneer het zeker is dat er geen fout is opgetreden, wordt dit gemeld met deze hook. De errorstring wordt dan gelijk aan 'none'.
\end{itemize}
Wanneer nu de hook wordt opgeroepen voor de module die in dit hoofdstuk besproken wordt, zal de errorstring opgeslagen worden bij de betreffende resource in de databank.

\subsection{hook\_stop\_observers()}
Wanneer een observe moet be\"{e}indigd worden, om welke reden dan ook (bijvoorbeeld wanneer de resource niet meer te bereiken is), wordt deze hook opgeroepen. Deze krijgt als parameters het IPv6-adres van het embedded device en de naam van de resource mee. Zo kan de module die deze hook implementeert ervoor zorgen dat de toestand consistent blijft voor de andere users.\\
Concreet zal de module die in dit hoofdstuk wordt besproken, in de databank aanduiden dat users de betreffende resource niet meer aan het observeren zijn. Dit wordt voor elke user gedaan die ge\"{i}nteresseerd was in deze resource.