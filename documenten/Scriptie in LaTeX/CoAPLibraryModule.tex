\chapter{CoAP library module} \label{coaplibrary}

In hoofdstuk \ref{CoAP} bekeken we de definitie, aspecten en functionaliteit van CoAP. In dit hoofdstuk bekijken we hoe een eigen CoAP-\textit{library} voor CoAP versie 13 in PHP werd ontwikkeld als Drupalmodule. De module stelt een Drupalgebruiker in staat CoAP-berichten op te stellen, te versturen en te ontvangen. Let wel, deze module heeft niet als doel om visueel iets voor te stellen op een website. Ze biedt enkel functionaliteit en is bijvoorbeeld te gebruiken in een andere module die dan uitgewisselde gegevens kan omvormen tot een visuele representatie. Dit laatste is wat wij doen in de uiteindelijk te ontwerpen module welke wordt toegelicht in hoofdstuk \ref{sensormodule}. De API-documentatie onder vorm van HTML-pagina's bevindt zich op de bijgevoegde CD-ROM.
\section{Doel}

Wanneer we trachtten CoAP-berichten op te stellen, te versturen en ontvangen in onze module, werd al snel het nut duidelijk van een aparte module die zou fungeren als CoAP-\textit{library}. Er ontstaat namelijk erg veel duplicatie van code, bovendien wordt de code onoverzichtelijk en slordig. Nog een zeer nadelig gevolg is dat de code niet hergebruikt kan worden in andere modules. Men zou al de code moeten doorspitten om net dat stuk te vinden waar CoAP gesproken wordt. Bovendien is het niet zeker dat die code zal voldoen aan de waarschijnlijk andere eisen van de nieuwe gebruiker. Wanneer de code niet fungeert in de nieuwe situatie, zal er veel tijd gespendeerd moeten worden aan debuggen en zal de frustratie oplopen bij de gebruiker. Kortom, het is duidelijk dat dit een zeer slechte praktijk is die ten alle kosten moet vermeden worden, het druist in tegen enkele van de belangrijkste programmeerprincipes.\\

\newpage
Met het nut bewezen bekijken we even wat een gebruiker van deze \textit{library} kan verwachten. Ze moet de gebruiker in staat stellen dynamisch berichten op te stellen, volledig naar eigen wens. Dit wil zeggen dat de verzameling operaties om een bericht op te stellen, alle mogelijke berichten moet kunnen genereren. Dit heeft als gevolg dat elke elementaire operatie moet kunnen worden uitgevoerd op een bericht. Opstellen van bijvoorbeeld een bepaald bericht aan de hand van slechts \'{e}\'{e}n functie is niet prioritair en dus bijkomstig. Het is uiterst belangrijk bij het ontwerp van deze \textit{library} dat de gebruiker zich niet meer hoeft te bekommeren om technische details zoals hexadecimale code die nodig is in een bericht. Alle technische details zitten verborgen in de CoAP-\textit{library}module. We besluiten dat de \textit{library} een gebruiker in staat moet stellen dynamisch en gebruiksvriendelijk berichten op te stellen, en dit met een minimum aan code.

\subsection{Essenti\"{e}le functies} \label{essentielefuncties}

We sommen enkele van de eerder vermelde elementaire functies op, deze opsomming is allesbehalve limitatief:

\begin{itemize}
\item Opstellen van de CoAP-\textit{header} en CoAP-\textit{token} waarbij de gebruiker het type, de methode en het \textit{token} zelf opgeeft. De \textit{token}lengte wordt afgeleid uit het \textit{token}. Wanneer geen \textit{token} gewenst is, kan de gebruiker een lege string meegeven.
\item Een CoAP-optie toevoegen aan het bericht waarbij de gebruiker slechts het optienummer en de waarde van de optie moet meegeven. De gebruiker hoeft zich hierbij niet te bekommeren over de encodering van opties in het resulterende CoAP-bericht.
\item De \textit{payload} toevoegen aan het bericht waarbij de gebruiker slechts de \textit{payload} zelf hoeft op te geven.  Dit houdt in dit geval in dat de \textit{payload marker} wordt toegevoegd en dat de lengte van de \textit{payload} wordt afgeleid uit de \textit{payload} zelf.
\item Een bericht versturen, hierbij onderscheiden we 2 mogelijkheden:
\begin{itemize}
\item Het sturen van een bericht zonder \textit{observe}-optie: Hierbij hoeft men enkel rekening te houden met \'{e}\'{e}n antwoord. Men kan dus het antwoord teruggeven als teruggeefwaarde van de functie die het bericht stuurt. Men hoeft zich niet te bekommeren om meerdere antwoorden die op willekeurige tijdstippen kunnen aankomen. Wel is het nodig rekening te houden met resources die grote antwoorden eventueel bloksgewijs opsturen. Hierbij moet de client zelf initiatief nemen om de volgende blokken iteratief op te halen. De client geeft hierbij bij elk blok aan welk blok hij wil ophalen (Zie paragraaf \ref{blocks}). Ook kan het gebeuren dat een server niet onmiddellijk kan antwoorden, de server kan dan kiezen om gewoon het antwoord laat te sturen of om gebruik te maken van \textit{separate response}. De server stuurt dan een lege ACK terug om de client ervan te vergewissen dat de aanvraag ontvangen is en zal dan later, wanneer de waarde beschikbaar is, antwoorden met een afzonderlijk antwoord (Zie paragraaf \ref{separate}).
\item Het sturen van een bericht met \textit{observe}-optie: Het antwoord dat hierop terug gestuurd wordt, bevat slechts \'{e}\'{e}n resourcewaarde als \textit{payload} en is slechts een bevestiging dat de server de client heeft toegevoegd aan de lijst van ge\"{i}nteresseerden. De server zal nu op willekeurige tijdstippen een antwoord sturen op eigen initiatief. Er moet dus een mechanisme voorzien worden dat het aankomen van die berichten opvangt. We zullen later in dit hoofdstuk zien (Zie paragraaf \ref{observe_hooks}) hoe we deze probleemstelling in de \textit{library} hebben opgelost.
\end{itemize}
Hierbij wordt de gebruiksvriendelijkheid doorgetrokken, de gebruiker staat namelijk niet in voor de controle van de aanwezigheid van een \textit{observe}optie. Dit wordt automatisch gedetecteerd door de CoAP-\textit{library}.
\item Operaties om een bericht te ontmantelen, hieronder verstaan we het parsen van onder andere de \textit{payload}, een optie op basis van optienummer, het \textit{message-ID}, het \textit{token}, ...
\end{itemize}

Merk op dat bij het genereren van CoAP-berichten ook een \textit{message-ID} nodig is. Ook hierop is de CoAP-\textit{library} voorzien, er wordt bijgehouden welke \textit{message-ID}'s al gebruikt zijn door telkens het laatst gebruikte \textit{message-ID} te incrementeren. Dit is een mechanisme dat aangeraden wordt in de CoAP-\textit{draft} \cite{coapDraft}.\\
Een soortgelijk principe wordt toegepast wanneer een \textit{token} moet worden gegenereerd. De gebruiker moet dan wel een lengte aangeven.\\
Ook wanneer een ACK of RST moet worden gegenereerd, wordt door aan te geven op welk bericht het antwoord moet worden gestuurd, automatisch het \textit{message-ID} uit het oorspronkelijk bericht geparsed en in het antwoord geplaatst. Hetzelfde principe geldt wanneer een \textit{token} moet worden overgenomen.

\subsection{Optionele functies} \label{optionelefuncties}

Sommige berichten zijn vaker nodig dan andere. Om de gebruiksvriendelijkheid van de \textit{library} te verhogen en de drempel om ze te gebruiken te verlagen, is het een goed idee enkele functies te voorzien om bepaalde volledige berichten op te stellen. Belangrijk hierbij is dat deze opgestelde berichten nog steeds aanpasbaar moeten zijn. Dit zorgt ervoor een gebruiker bijvoorbeeld al een basisbericht kan opstellen en het daarna nog naar eigen wens kan aanpassen, wat de gebruiker veel tijd en code bespaart. We geven enkele voorbeelden die ook ge\"{i}mplementeerd zijn in de \textit{library}, deze opsomming is alweer niet limitatief:
\begin{itemize}
\item Opstellen van een basis GET-\textit{request}: hierbij krijgt de gebruiker meteen de kans om een \textit{Uri-Path} mee te geven aan het bericht. De benodigde \textit{Uri-Path}-optie(s) worden dan automatisch toegevoegd door de \textit{library} op basis van de opgegeven Uri-Path. Wanneer de gebruiker geen \textit{URI-path} meegeeft, wordt er ook geen optie toegevoegd aan het bericht.
\item Opstellen van een basis GET-\textit{request} met \textit{observe}optie: deze operatie is zeer vergelijkbaar met de vorige, het enige verschil is dat er een lege \textit{observe}optie wordt toegevoegd. Het is hierbij verplicht een \textit{token} op te nemen in het bericht, hiervoor moet de gebruiker enkel de lengte van het token opgeven. Bij ontvangst van deze \textit{request} zal de server, waarnaar het bericht wordt verstuurd, de \textit{client} toevoegen aan de lijst met ge\"{i}nteresseerden indien de server \textit{observable} is. Om de goede programmeerprincipes te volgen wordt in deze operatie gebruik gemaakt van de vorige operatie. Dit om duplicatie van code te vermijden.
\item Automatisch genereren van een ACK op basis van een opgegeven bericht: de gebruiker hoeft enkel het bericht mee te geven waarop de ACK moet worden opgesteld. Het \textit{message-ID} wordt automatisch overgenomen uit het oorspronkelijk bericht. Naast het feit dat de gebruiksvriendelijkheid verhoogd wordt, heeft deze operatie nog een niet te verwaarlozen nut. De kans op fouten wordt namelijk veel kleiner omdat de ACK automatisch gegenereerd wordt, menselijke fouten zijn dus zo goed als uitgesloten als deze operatie op punt staat.
\item Automatisch genereren van een RST op basis van een opgegeven bericht: deze operatie is volledig analoog aan de vorige met dat verschil dat het type van dit bericht RST is in plaats van ACK.
\end{itemize}

\section{Implementatie}

In deze paragraaf wordt besproken hoe de \textit{library} effectief ge\"{i}mplementeerd werd. De volgorde van de subparagrafen is tevens chronologisch. 

\subsection{Proceduregericht}

De eerste versie van de CoAP-\textit{library} werd proceduregericht geprogrammeerd. Dit houdt in dat geen staten of objecten bijgehouden worden. Bijgevolg moet de gebruiker zelf het bericht bijhouden onder een vorm die hij/zij zelf kiest. Deze versie van de CoAP-\textit{library} verwachtte echter het bericht onder de vorm van een hexadecimale string. Met een hexadecimale string bedoelen we een string die zich beperkt tot 16 hexadecimale karakters. Alle benodigde operaties die eerder vermeld werden, werden ge\"{i}mplementeerd. Alhoewel deze eerste versie al zeker een stap in de goede richting was, zijn er toch wel enkele nadelen die de kop opsteken. Zoals eerder al vermeld, is de gebruiker verplicht zelf de hexadecimale string bij te houden die het bericht voorstelt. Niet elke gebruiker is bekend met het gebruik van hexadecimale strings. Een tweede nadeel heeft te maken met bescherming van het bericht. Wanneer de gebruiker de hexadecimale string bijhoudt, kan die worden aangepast naar believen. Het bericht kan zo vervormd en mogelijks nutteloos worden. Bovendien kan de gebruiker zonder het te beseffen het bericht door \'{e}\'{e}n of andere operatie omvormen tot een normale string met \textit{American Standard Code for Information Interchange} (ASCII)-karakters \nomenclature{ASCII}{American Standard Code for Information Interchange}. Dit heeft mogelijk als gevolg dat de \textit{library} het bericht zal omvormen tot een verkeerde hexadecimale string. Kortom, er is nog ruimte voor verbetering en een objectgerichte implementatie lijkt voor de hand liggend.

\subsection{Objectgericht}

In de vorige subparagraaf zagen we de nadelen van een proceduregerichte oplossing. Het zijn net deze punten waar een objectgerichte oplossing goed op scoort. De tweede versie van de CoAP-\textit{library} maakt gebruik van twee klassen welke besproken worden in de volgende subparagrafen.

\subsubsection{CoAPFactory}

Zoals de naam al suggereert, wordt deze klasse gebruikt voor generatie van CoAP-berichten. De gebruiker maakt eerst een instantie aan van de CoAPFactory-klasse. Dit object kan dan gebruikt worden om CoAP-berichten aan te maken. Het is deze klasse die de eerder besproken handige functies (zie \ref{optionelefuncties}) implementeert om bepaalde berichten aan te maken, samen met de operatie die de \textit{header} en \textit{token} opstelt. Alle operaties die een berichtobject aanmaken geven een object terug van de klasse CoAPMessage, deze klasse wordt hierna besproken. De constructor van deze \textit{factory}-klasse ontvangt volgende parameters:
\begin{itemize}
\item Modulenaam: deze parameter bevat de naam van de module die gebruik maakt van de CoAP-\textit{library}, de reden voor deze parameter wordt hierna uitgelegd in paragraaf \ref{observe_hooks}.
\item IPv6-adres: deze parameter bevat een geldig IPv6-adres, dit is het IPv6-adres van het \textit{embedded device} waarop de beoogde resource is aangesloten.
\item \textit{Uri-path}: deze parameter bevat een \textit{Uri-path} van een resource op het \textit{embedded device} dat aangegeven wordt door het IPv6-adres. Deze parameter mag achterwege gelaten worden, het \textit{Uri-path} is dan leeg en duidt het \textit{embedded device} zelf aan.
\end{itemize}
Zoals blijkt uit de parameters wordt een \textit{factory} per gewenste resource aangemaakt.

\subsubsection{CoAPMessage}

Deze klasse representeert het bericht zelf. Het bevat alle onderdelen van het betreffende bericht in een gemakkelijk te gebruiken vorm. Dit heeft als voordeel dat de gebruiker van de \textit{library} zich bijvoorbeeld niet hoeft te bekommeren om volgorde van toevoegen bij opties. Wanneer het bericht verzonden moet worden, wordt de hexadecimale string opgesteld om daarna verzonden te worden. De \textit{library} verzamelt dus eerst alle gegevens en zorgt er zelf voor dat het bericht correct wordt opgesteld. Het is deze klasse die de essenti\"{e}le operaties (Zie paragraaf \ref{essentielefuncties}) implementeert op het opstellen van de \textit{header} en \textit{token} na, zodanig dat het bericht kan worden aangepast naar eigen wensen en noden. Het bericht kan dan gemakkelijk worden verstuurd door een \textit{send}operatie op het object uit te voeren. Een IPv6-adres opgeven hoeft niet meer, dit is reeds gebeurd bij constructie van de \textit{factory} die dit bericht heeft aangemaakt. Aangezien CoAP werkt met UDP, moet er een UDP-\textit{socket} geopend worden. Bovendien moet in het geval de \textit{observe} functionaliteit gebruikt wordt, de \textit{socket} onderhouden worden. Daar berichten later kunnen toekomen op initiatief van de server. Dit is ook het geval bij \textit{separate response}.\\
Deze UDP-\textit{socket} wordt geopend in een achtergrondproces, zodat de \textit{socket} kan gebruikt worden zonder andere processen te blokkeren. Het betreft hier een achtergrondproces dat gemaakt wordt in Drupal aan de hand van de \textit{Background Process}-module \cite{backgroundProcessModule} (Zie paragraaf \ref{aspecten}). Bijgevolg is deze implementatie niet gebonden aan een bepaalde webserver (Apache, nginx, ...).

\subsection{Hooks voor notificaties} \label{observe_hooks}

Eerder werd al aangehaald dat er een speciale voorziening nodig is voor de \textit{observe}-functionaliteit. Hierbij kan de server op eigen initiatief notificaties sturen naar ge\"{i}nteresseerde \textit{clients}. Enkele alternatieven werden bedacht en overwogen, het een al beter dan het ander:
\begin{itemize}
\item \textit{Socket} teruggeven: Dit houdt in dat de \textit{send}-functie die opgeroepen wordt in de CoAP-\textit{library} als teruggeefwaarde de \textit{socket} zou teruggeven. Dit heeft echter als gevolg dat een gebruiker verder zelf de \textit{socket} moet onderhouden en telkens de nodige berichten moet opbouwen, versturen en ontvangen. Het spreekt voor zich dat dit geen goede oplossing is. De CoAP-\textit{library} wordt zo allesbehalve modulair en een eventuele gebruiker ervan moet al een redelijke hoeveelheid technische kennis hebben om ze te gebruiken.
\item Databank: bij dit alternatief zou men de \textit{socket} toch beheren in de CoAP-\textit{library} zelf en de notificaties opslaan in de databank. Men kan dan bijvoorbeeld een gebruiker van de module een naam van een databanktabel laten opgeven en de notificaties daarin opslaan. Dit is al een betere oplossing, maar deze heeft ook wel wat nadelen. Er is namelijk geen enkele controle mogelijk of de kolommen van de databank wel kloppen en nog belangrijker, of de tabel wel bestaat. Ook is er nu niet echt sprake van abstractie, de gebruiker moet zich aanpassen aan de \textit{library}. Bovendien moet de gebruiker kennis hebben over het gebruik van een databank, wil hij de \textit{library} gebruiken.
\item \textit{Hook}mechanisme: Dit is het laatste en door ons gekozen alternatief. De CoAP-\textit{library} definieert hierbij 3 hooks die een gebruiker moet implementeren. \'{E}\'{e}n van de voordelen hiervan is dat de Drupalontwikkelaar normaal gezien al bekend is met het \textit{hook}mechanisme van Drupal zelf. Het gebruikte mechanisme is namelijk analoog, de \textit{hook} wordt ge\"{i}mplementeerd door het woord \textit{hook} te vervangen door de naam van de module. Deze moeten ge\"{i}mplementeerd worden maar de functies zelf mogen leeg zijn. We sommen even de te implementeren \textit{hooks} op:
\begin{itemize}
\item \textit{hook\_receive\_notification}: Deze \textit{hook} wordt opgeroepen telkens wanneer een notificatie binnen komt. De CoAP-\textit{library} bouwt een response-object op van de klasse CoAPMessage en geeft deze mee als argument met de hook. Zo kan de gebruiker zelf beslissen wat er met het antwoord moet gebeuren. Men kan zo spreken van een hoge mate van abstractie.
\item \textit{hook\_receive\_error}: Wanneer een fout gebeurt, bijvoorbeeld een sensor die laat of zelfs niet meer reageert, wordt deze \textit{hook} opgeroepen. Als argumenten worden de foutboodschap, het IPv6-adres en \textit{Uri-path} van de resource meegegeven. Alweer kan de gebruiker van de \textit{library} zelf beslissen wat er met deze foutboodschap moet gebeuren.
\item \textit{hook\_stop\_observers}: Wanneer een \textit{observe} op een resource stopt, om welke reden dan ook, wordt deze \textit{hook} opgeroepen. Het kan hier gaan om het uitblijven van antwoorden, een \textit{socket} die sluit, enzoverder. Dit biedt een gebruiker van de \textit{library} de kans om de consistentie van de eigen module te behouden en fouten te vermijden. Men kan bijvoorbeeld melden op een eventueel gemaakte website dat de \textit{observe} gestopt is. Als parameters worden het IPv6-adres en het \textit{Uri-path} van de resource meegegeven zodat de gebruiker weet over welke resource het gaat.
\end{itemize}
\end{itemize}

We merken verder nog op dat de CoAP-\textit{library} zelf instaat voor het bijhouden van de te observeren resources. Bovendien wordt om de resource zo weinig mogelijk te belasten, slechts \'{e}\'{e}n \textit{observe} uitgevoerd op de resource, ongeacht hoeveel gebruikers erin ge\"{i}nteresseerd zijn. Een \textit{observe} wordt pas gestopt wanneer geen enkele gebruiker meer ge\"{i}nteresseerd is in de resource.

% HIER VERDERWERKEN

\subsection{Opvangen van verloren berichten} \label{exponentialBackoff}

Omdat CoAP gebruik maakt van UDP kunnen pakketten verloren gaan. Dit moet dus opgevangen worden indien CON-berichten verstuurd worden. In de CoAP-\textit{draft} \cite{coapDraft} wordt \textit{exponential back-off} voorgeschreven. In de CoAP-\textit{library} werd die ge\"{i}mplementeerd met de standaardwaarden die eveneens in de CoAP-\textit{draft} \cite{coapDraft} staan. Het principe is dat wanneer geen ACK ontvangen wordt als antwoord op het CON-bericht, het CON-bericht opnieuw verstuurd wordt met daartussen exponentieel stijgende perioden tot een ACK ontvangen wordt of een maximum aantal verzendingen overschreden wordt. Hiervoor moeten 2 dingen worden bijgehouden: een time-out waarde en een \textit{retransmission counter} die bijhoudt hoeveel keer het CON-bericht al opnieuw werd verstuurd. De time-outwaarde wordt ge\"{i}nitialiseerd op een random waarde tussen ACK\_TIMEOUT en ACK\_TIMEOUT*ACK\_RANDOM\_FACTOR, ACK\_TIMEOUT en ACK\_RANDOM\_FACTOR zijn constanten. De \textit{retransmission counter} wordt initieel ingesteld op 0. Wanneer de time-out overschreden wordt en de \textit{retransmission counter} nog steeds een waarde bevat die kleiner is dan MAX\_RETRANSMIT (nog een constante), wordt het CON-bericht opnieuw verzonden en de time-outwaarde verdubbeld. De constanten werden in de CoAP-\textit{library} ingevuld met volgende waarden die voorgeschreven worden in de CoAP-\textit{draft}  \cite{coapDraft}:
\begin{itemize}
\item \textit{ACK\_TIMEOUT}: 2 seconden
\item \textit{ACK\_RANDOM\_FACTOR}: 1,5
\item \textit{MAX\_RETRANSMIT}: 4
\end{itemize}
