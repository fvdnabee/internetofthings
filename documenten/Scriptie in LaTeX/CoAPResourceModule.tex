\chapter{CoAP resource module} \label{resourcemodule}

Nu we genoeg kennis hebben over Drupal en CoAP en een CoAP library ter beschikking hebben, kunnen we overgaan tot de uiteindelijk te ontwikkelen module. Het is deze module die een eindgebruiker zal installeren. Ze biedt dan de mogelijkheid om op een gebruiksvriendelijke en dynamische manier sensoren te bekijken en beheren van op de Drupal-website, en dit zonder technische kennis nodig te hebben van CoAP of programmatie in Drupal. We bekijken eerst globaal wat de module concreet moet aanbieden. Daarna bekijken we hoe de module zal opgebouwd worden. Eens we dit weten, kunnen we overgaan tot de verschillende versies van de ontwikkelde module en de implementatie ervan.

\section{Architectuur}
In deze paragraaf bespreken we de architectuur van de module en hoe die inpast in het Drupal systeem. We behandelen tevens ook enkele belangrijke aspecten die in rekening werden gebracht. Vervolgens lichten we enkele belangrijke onderdelen van de module toe.\\
De architectuur wordt weergegeven in figuur \ref{fig:architectuur}. De acties aangeduid met een gekleurd bolletje gebeuren altijd bij een request, de acties aangeduid met een leeg bolletje zullen pas gebeuren wanneer geen geldige waarde uit de databank kan worden gehaald (Zie paragraaf \ref{caching}).\\
We overlopen de opeenvolgende stappen bij een request aan de hand van figuur \ref{fig:architectuur}:
\begin{enumerate}
\item De client start een periodieke poll naar de webserver waarop Drupal draait. Deze poll gebeurt onder vorm van een AJAX call.
\item De CoAP Resource module voert een query uit op de databank om een geldige waarde op te vragen indien die aanwezig is.
\item De databank stuurt een resultatenset terug die een geldige waarde bevat, of leeg is indien er geen geldige waarde meer is.
\item In deze stap zijn er twee mogelijkheden:
\begin{itemize}
\item Indien er een geldige waarde aanwezig is in de databank, wordt deze teruggestuurd naar de client als antwoord op de AJAX call. De request eindigt dan hier.
\item Indien er geen geldige waarde aanwezig is in de databank, wordt een beroep gedaan op de CoAP library module om een nieuwe waarde op te vragen aan de resource. 
\end{itemize}
Dit mechanisme zorgt ervoor dat de resource niet onnodig belast wordt (Zie paragraaf \ref{caching}).
\item De CoAP library module stuurt een CoAP GET-request naar de resource.
\item De resource stuurt zijn waarde terug in een response bericht als antwoord op de GET-request.
\item De CoAP library roept een hook op die de CoAP Resource module ge\"{i}mplementeerd heeft, om die ervan op de hoogte te brengen dat er een waarde is binnengekomen.
\item De hook zal ervoor zorgen dat de nieuwe, ontvangen waarde opgeslagen wordt in de databank.
\item Uiteindelijk wordt de waarde ook teruggestuurd naar de client die de request heeft gestart.
\end{enumerate}
\begin{figure}
\includegraphics[width=1\textwidth]{fig/architectuur}
\caption{Architectuur van de CoAP resource module in Drupal}
\label{fig:architectuur}
\end{figure}

\subsection{Functionaliteit}

De bedoeling van deze module is de eindgebruiker in staat te stellen om gemakkelijk sensoren te beheren op zijn/haar website. Belangrijk hierbij is dat elke Drupal gebruiker die een website maakt, deze kan gebruiken zonder extra kennis nodig te hebben over CoAP. Ook is het niet de bedoeling dat de eindgebruiker zelf nog moet programmeren in Drupal om de module te kunnen gebruiken. Kortom, de module moet out-of-the-box werken en zoveel mogelijk omvatten wat mogelijk is met CoAP-sensoren.\\
Concreet houdt dit onder andere in dat bij installatie van de module enkele content types mee worden ge\"{i}nstalleerd. Het betreft hier een content type voor een enkele CoAP resource en een content type voor een CoAP device waarop meerdere resources zitten. Ook hier werd weer modulair gewerkt, de resources worden bij een CoAP device aangegeven onder vorm van het content type CoAP resource. Deze content types zorgen ervoor dat de gebruiker slechts met enkele muisklikken resources en devices kan toevoegen en onmiddellijk kan beginnen met het beheren en bevragen van de resources. Verder worden bij installatie ook alle benodigde databanktabellen gecre\"{e}erd.\\

De configuratie die de gebruiker moet doen zoals bijvoorbeeld het toevoegen van een resource, moet gebruiksvriendelijk verlopen. Hiervoor wordt gebruik gemaakt van resource discovery. In het geval van een CoAP device hoeft de gebruiker enkel het IPv6-adres ervan op te geven. Aan de hand van resource discovery wordt dan een lijst gegenereerd van resources. Wanneer de gebruiker op een resource klikt, krijgt die een visuele representatie van het content type CoAP resource.\\
Wanneer de gebruiker een enkele resource wil toevoegen, hoeft die enkel de URI van de resource op te geven. Deze bestaat uit een IPv6-adres en een URI-path, gescheiden door een '/'. De module zal aan de hand van een specifieke resource discovery voor deze resource, de overige informatie en parameters van de resource ophalen en opslaan in de databank (Zie paragraaf \ref{resourceDiscovery}). De resource wordt bij de discovery gespecifieerd door een Uri-Query optie toe te voegen aan het CoAP pakket met een waarde onder de vorm van 'href=resourcenaam'. De parameters bestaan onder andere uit het content format dat de resource teruggeeft (plain text, JSON, XML, ...), of de resource al dan niet observable is, enzovoort...\\

Eens de gebruiker de gewenste resources heeft toegevoegd aan zijn/haar website, is het de bedoeling dat de 4 REST-methodes GET, PUT, POST, DELETE kunnen uitgevoerd worden, de gebruiker zal ervan op de hoogte gebracht worden wanneer een methode niet ondersteund wordt. Naast deze methodes kan een sensor ook nog observable zijn (zie hoofdstuk \ref{CoAP}), de gebruiker moet dus ook in staat gesteld worden om notificaties te ontvangen van een resource. Ook wanneer een gebruiker de website verlaat moet het mogelijk zijn de observe te laten doorlopen.

\subsection{Belangrijke aspecten}

Deze module werd ontworpen met het oog op bepaalde aspecten waarmee rekening moet worden gehouden. We sommen enkele van de belangrijkste op.

\subsubsection{Modulariteit}
Een van de grote troeven van Drupal is de modulariteit die aangeboden wordt. Het is dan ook van uiterst belang dat onze module dit principe niet verbreekt, maar juist doorzet. In hoofdstuk \ref{coaplibrary} zagen we al hoe een aparte CoAP library ontwikkeld werd. Dit heeft als gevolg dat elke Drupal gebruiker de kans heeft gebruik te maken van de library en dus zelf een module zou kunnen bouwen gelijkaardig aan de onze.\\
Dit geldt ook voor deze module die we nu bespreken, deze is ook bruikbaar voor elke gebruiker die dat wil. Naast het installeren van de CoAP library en deze module, hoeft de gebruiker niets extra te doen om deze module te gebruiken. Databanktabellen worden gecre\"{e}erd en content types worden ge\"{i}nstalleerd, zonder dat de gebruiker daar iets hoeft voor te configureren.\\
Onze module heeft zo ook enkele modules nodig die de gebruiker eerst moet installeren. Drupal zal hierbij automatisch aangeven welke modules eerst moeten worden geïnstalleerd. Het betreft de volgende modules:
\begin{itemize}
\item Background process \cite{backgroundProcessModule}: Deze module maakt het gebruik van achtergrondprocessen mogelijk. (bvb voor observe)
\item Progress \cite{progressModule}: Deze module moet worden toegevoegd omdat de Background Process module hiervan afhankelijk is.
\item CoAP library (Zie hoofdstuk \ref{coaplibrary}): Onze eigen geschreven module die instaat voor alle CoAP communicatie.
\item Entity API \cite{entityApiModule}: Een veelgebruikte module (wordt namelijk opgenomen in de core van Drupal 8). Breidt de functionaliteit uit die met entities kan verwezenlijkt worden. Deze module wordt besproken in \ref{gebruikEntityAPI}.
\item Node reference \cite{nodeReferenceModule}: Een module die gebruikt wordt om in een bepaalde node te verwijzen naar andere nodes.
\end{itemize}

\noindent
Er zijn ook modules die niet strikt noodzakelijk zijn maar wel extra functionaliteit bieden:
\begin{itemize}
\item Views\cite{viewsModule}: Maakt het gebruik van views mogelijk.
\item Views UI: Stelt een user interface ter beschikking om eigen views te maken en te beheren. Deze module is onderdeel van de views module.
\end{itemize}

\subsubsection{Minimalisatie van netwerkbelasting}
Mogelijks zijn meerdere gebruikers van een Drupal-website ge\"{i}nteresseerd in een observable resource. Het is niet aanvaardbaar dat de netwerkbelasting zou stijgen met het aantal ge\"{i}nteresseerden voor die resource. Daarom gedraagt Drupal zich eigenlijk als intermediaire server voor de eindgebruikers. Er wordt namelijk maar \'{e}\'{e}n observe uitgevoerd door Drupal, ongeacht het aantal gebruikers dat ge\"{i}nteresseerd is in die resource. De notificaties worden op de server in de databank gestopt en het zijn deze waarden waarop de gebruikers uiteindelijk pollen.\\
Bovendien zorgt dit voor een vorm van controle over verkeer naar de resources, de gebruikers van de website kunnen namelijk niet zelfstandig CoAP praten met de resources. % Een voorbeeld hiervan is de demo van de module op onze website (http://www.thesisinternetofthings.tk). Enkel ingelogde gebruikers zijn in staat een observe uit te voeren. Dit om te vermijden dat gelijk wie een observe kan starten, men kan namelijk vergeten de observe af te sluiten, waardoor de databank meer en meer opgevuld wordt.

\subsubsection{Asynchroniteit}
In een eerste fase van deze module werd er gebruik gemaakt van een formulier. Bij het indienen van dit formulier, werd eerst de request om de waarde op te halen uitgevoerd en dan gewacht op de response om de nieuwe pagina op te bouwen. Het spreekt voor zich dat dit geen goede oplossing is, daar de gebruiker zal moeten wachten op de pagina wanneer de communicatie traag is of misloopt. De gebruiker kan snel het idee krijgen dat er geen verbinding meer is met de website.\\

In hoofdstuk \ref{Drupal} zagen we dat een mogelijke oplossing het gebruik van jQuery is. In deze situatie is jQuery echter geen goede optie omdat jQuery de databank van Drupal niet zomaar kan manipuleren. Hiervoor zouden een connectiestring, wachtwoord en dergelijke gegevens nodig zijn, en jQuery van die informatie voorzien is een grote bedreiging voor de veiligheid, bovendien zou dit een oplossing zijn met een zeer sterke koppeling, wat nooit een goed idee is.\\
De gebruikte oplossing illustreert alweer de voordelen van een open source platform met een uitgebreide community. Er is namelijk al een Background Process module gemaakt in het verleden, het zou dus zonde zijn om hier niet dankbaar gebruik van te maken. Zoals de naam suggereert, biedt de Background Process module de mogelijkheid om achtergrondprocessen op te starten. Deze draaien op de achtergrond op de server en storen dus geen andere processen zoals het opbouwen van een pagina voor de gebruiker, waardoor de gebruiker dus niet geconfronteerd wordt met lange wachttijden.\\
Sterker nog, er is ook een functie voorzien om een HTTP GET-request uit te voeren, waarbij je een callback-functie opgeeft. Wanneer er een response is, zal dus automatisch de opgegeven functie als achtergrondproces opgeroepen worden met de response als argument. Deze functie zal dus goed van pas komen in de eerste versie van de module, die gebruik maakt van een HTTP/CoAP-proxy. Deze wordt beschreven later in dit hoofdstuk (Zie paragraaf \ref{proxy}).

\subsubsection{Strategie bij ontvangst van waarden}
\paragraph{Push-strategie:}

De mooiste oplossing en tevens degene met het minste aandeel aan overhead, is een oplossing waarbij de server zelf op eigen initiatief data kan sturen naar de client. Merk op dat we hier als server de Drupal server bedoelen en als client de browser. Hierbij is dan geen polling-mechanisme nodig door de client, wat de netwerkbelasting drastisch verlaagt en de verantwoordelijkheid verschuift naar de server.\\
Om een push-strategie te verwezenlijken werd een uitgebreide literatuurstudie van node.js uitgevoerd. Node.js is een javascript-library die je in staat stelt bi-directioneel verkeer te verwezenlijken. Hierbij wordt gebruik gemaakt van kanalen die worden opgezet, zo'n kanaal kan dan door beide partijen gebruikt worden.\\
Concreet zou het in de context van deze masterproef mogelijk zijn om met node.js een JavaScript-functie op te roepen bij de client op initiatief van de server.\\

Er is meermaals gepoogd dit te realiseren, maar de summiere documentatie van node.js laat op sommige vlakken te wensen over. Zo zijn we er niet in geslaagd documentatie te vinden over het opzetten van een eigen kanaal of een bestaand kanaal te gebruiken.\\
Bovendien is het nodig voor node.js om een extra server te draaien waarlangs het verkeer moet passeren. Aangezien het vaak niet mogelijk is om de shell van de webserver te gebruiken in een free-hosting omgeving, is dit een erg groot nadeel. Er bestaan wel servers die je kan gebruiken, maar dit tegen betaling. Wij, als ontwikkelaar van de module, kunnen niet verwachten dat een eindgebruiker een extra server ter beschikking heeft of dat zelfs wil. Het is de bedoeling dat onze module zo veel mogelijk out-of-the-box bruikbaar is.\\

De conclusie is dat wij geopteerd hebben geen gebruik te maken van node.js en dus ook niet van een push-strategie.

\paragraph{Pull-strategie: }

Aangezien een push-strategie niet of moeilijk kan gebruikt worden, hebben wij gekozen voor een pull-oplossing.\\

Uiteraard was de eerste reactie gebruik te maken van de Drupal-community en dus te zoeken in de vele modules die beschikbaar zijn. Er is tot op heden geen module geschreven door iemand anders in de Drupal-community dat ons probleem behandelt. De inspiratie voor de uiteindelijke oplossing werd wel gehaald uit een bestaande module, namelijk de Block Refresh-module \cite{blockRefreshModule}.\\
Deze laatste maakt gebruik van jQuery en AJAX calls om periodiek de inhoud van een block te refreshen, waarbij je zelf de lengte van de periode kan bepalen. In jQuery loopt een timer die periodiek een JavaScript-functie oproept. In deze functie wordt dan een AJAX call uitgevoerd naar de Drupal server, die op zijn beurt een antwoord terug stuurt.\\

Wij hebben geopteerd het mechanisme licht te wijzigen in plaats van de module zelf te gebruiken. Aan de basis van deze beslissing liggen drie redenen:
\begin{itemize}
\item Wij wensen de content slechts aan te passen wanneer nodig. Dit wil zeggen, wanneer een nieuwe waarde is binnengekomen. Bovendien hoeft niet alle content vernieuwd te worden, dit doet de Block Refresh module wel.
\item De configuratie van de periode voor het vernieuwingsinterval is in onze ogen relatief omslachtig. De gebruiker moet al een configuratievenster openen om het interval te wijzigen, wat wachttijden met zich meebrengt. Het zal blijken dat in onze uiteindelijke module het interval snel en gemakkelijk te wijzigen is. 
\item De uiteindelijke module zal geen blocks meer gebruiken, maar content types. Dit maakt het gebruik van de Block Refresh module zelfs onmogelijk.
\end{itemize}

De aangepaste methode werkt als volgt: Wanneer de pagina geladen wordt bij de client, start een timer die periodiek een AJAX call uitvoert naar de Drupal server. De gebruiker kan hierbij bepalen hoe lang die periode moet zijn. Op de Drupal server is dan een AJAX callback functie gedefinieerd aan de hand van de hook hook\_menu(). Deze hook wordt gebruikt om menu items toe te voegen aan de site en om AJAX callbacks te definieren. Alle output die gegenereerd wordt in deze callback wordt als antwoord teruggestuurd op de AJAX callback.\\

Wat de callback terugstuurt en hoe die inhoud wordt verwerkt, verschilt per versie van onze module. Dit zal dan ook besproken worden in de gepaste paragrafen (Zie paragraaf \ref{evolutie}).

\subsubsection{Caching}\label{caching}
Een bericht kan een maximum levensduur hebben, dit wordt aangegeven met een max-age optie (optie 14) in het bericht. Deze bevat dan een numerieke waarde die aangeeft in seconden hoelang de waarde als geldig mag worden beschouwd. Wanneer deze maximum levensduur overschreden wordt, mag deze waarde niet meer worden gebruikt. Dan moet bij een volgende aanvraag door een gebruiker een nieuwe waarde worden opgehaald van de resource. Bijgevolg wordt een opgehaalde waarde in de databank gestopt. Wanneer de maximum levensduur nog niet overschreden is bij een aanvraag, wordt de waarde uit de databank gehaald. De resource en het netwerk worden dan dus niet onnodig belast. Dit zorgt er ook voor dat de belasting op een resource niet evenredig stijgt met het aantal gebruikers die er een waarde van willen opvragen.\\
Dit aspect is zeker een van de meer belangrijke omdat verbindingen naar een resource vaak een beperkte bandbreedte kennen. Bovendien bestaat de energievoorziening van sensoren vaak uit een batterij. Het werk dat zo'n sensor moet verrichten, moet dus worden geminimaliseerd.

\subsection{Content-type in de databank}
Onder content-type van de databank verstaan we de definitie van nodige databanktabellen en -kolommen. Er moet namelijk heel wat data opgeslagen worden waaronder de verschillende resources, users en de opgehaalde waarden.\\

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/databankModel}
\caption{EER-diagram van de door ons toegevoegde tabellen.}
\label{fig:databankModel}
\end{figure}

We onderscheiden drie tabellen (Zie figuur \ref{fig:databankModel}):
\subsubsection{coap\_resource\_resource}
Deze tabel bevat een entry voor elke CoAP resource die nodig kan zijn en bovendien een entry voor elk embedded device waarop de resources aangesloten zijn. Deze tabel bevat de volgende kolommen (Zie figuur \ref{fig:databankModel}):
\begin{itemize}
\item uri: Dit is de volledige URI van de resource, dus IPv6-adres en URI-path. Dit is tevens de primaire sleutel van deze kolom, elke waarde moet dus uniek zijn.
\item obs, rt, ct, ifd, sz, title, anchor en rel: Deze kolommen bevatten waarden die bekomen worden bij resource disovery. Deze werden eerder uitgelegd in paragraaf \ref{resourceDiscovery}.
\item last\_error: Deze kolom bevat voor elke resource de laatst opgetreden fout. Zo kan een browser te weten komen bij polling dat er iets foutliep bij communicatie met de betreffende resource.
\item created: De UNIX timestamp van de tijd waarop deze resource aangemaakt werd.
\item changed: De UNIX timestamp van de tijd waarop deze resource het laatst gewijzigd werd.
\item not\_in\_core: Een waarde om aan te geven of deze resource nog in de well-known/core zit van een device.
\end{itemize}
\subsubsection{coap\_resource\_interested\_user}
In deze tabel wordt bijgehouden welke users ge\"{i}nteresseerd zijn in specifieke resources en devices. Ze bevat een entry voor elk koppel user/resource en user/device en wordt impliciet geassoc\"{i}eerd met een instantie van respectievelijk coap\_resource of coap\_device. Op die manier kan per user worden bijgehouden wat hij/zij met een bepaalde resource wil doen. Ze bestaat uit de volgende kolommen:
\begin{itemize}
\item uid: Een unieke identificatie voor een gebruiker. Dit ID is overgenomen uit Drupal, daar hebben alle gebruikers ook een uniek User ID. Deze kolom is tevens deel van de primaire sleutel.
\item uri: De URI van de resource waarin de gebruiker ge\"{i}nteresseerd is. Dit is dezelfde URI als in de vorige tabel (coap\_resource\_resources). Deze kolom vormt dus een foreign key en maakt tevens deel uit van de primaire sleutel.
\item nid: Een unieke identificatie van de node (Node ID)\nomenclature{nid}{Node ID} waaraan de resource gekoppeld is in Drupal. Deze kolom is ook deel van de primaire sleutel.
\item device: Deze waarde geeft aan of het een resource of een volledig embedded device betreft (0 = resource, 1 = device).
\item observe: Deze waarde geeft aan of de gebruiker momenteel de resource wil observeren of niet (0 = niet observeren, 1 = wel observeren).
\item polling\_interval: Dit is de periode in seconden tussen twee polls van de browser naar de Drupal server, deze is default drie seconden.
\item new: Deze waarde duidt aan of er inmiddels een nieuwe discovery is uitgevoerd of bezig is voor een device. Deze waarde heeft momenteel enkel voor devices. (0 = up-to-date, 1 = discovery bezig, 2 = discovery klaar)
\end{itemize}
De primaire sleutel bestaat uit de combinatie van de kolommen uid, uri en nid. Elke combinatie van waarden uit deze drie kolommen moet per entry uniek zijn.

\subsubsection{coap\_resource\_value}
Deze tabel bevat een entry voor elke waarde die is binnengekomen. Bovendien wordt een nieuwe waarde even veel keren toegevoegd als er ge\"{i}nteresseerden zijn voor die waarde op dat moment. Dit lijkt op het eerste zicht redundante informatie, maar het heeft wel degelijk nut. Zo kan men bijvoorbeeld later te weten komen voor een bepaalde user, welke waarden hij/zij in welke periode heeft opgevraagd. De tabel bevat de volgende kolommen:
\begin{itemize}
\item hid: Een uniek ID voor de entry automatisch gegenereerd bij toevoegen aan de databank. Dit is de primaire sleutel, dus deze waarden moeten uniek zijn.
\item uid: Het ID van de user waarvoor deze waarde opgeslagen is. Dit is hetzelfde ID als in de coap\_resource\_users-tabel en vormt dus een foreign key.
\item uri: De URI van de resource waarvan deze waarde komt. Dit is dezelfde URI als in de coap\_resource\_resources-tabel en vormt dus een foreign key.
\item content\_format: Bevat voor elke entry het formaat van het bericht, aangeduidt met een leesbare naam (bijvoorbeeld plain text, JSON, ...). 
\item payload: De payload van het bericht in leesbare vorm.
\item parsed\_value: Indien mogelijk bevat dit een waarde die geparset is uit de payload, bijvoorbeeld een numerieke waarde. Indien er geen waarde kon geparset worden bevat deze kolom gewoon de payload.
\item max\_age: Geeft aan wat de geldigheidsduur is voor deze waarde, deze is default nul.
\item timestamp: Het tijdstip waarop de waarde in de databank werd opgeslagen in mysql timestamp-formaat. Deze wordt automatisch gegenereerd. Samen met de max-age kan men dus bepalen of de waarde nog geldig is.
\item original\_response: De originele response op het CoAP request-bericht in hexadecimale vorm.
\item new: Geeft aan of de waarde reeds opgehaald werd om te tonen aan de gebruiker (0 = reeds afgehaald, 1 = nog niet afgehaald, default waarde = 0).
\end{itemize}

\subsection{Content-types in Drupal}

Bij installatie van de module worden twee content types mee ge\"{i}nstalleerd. We bespreken wat de mogelijkheden ervan zijn en hoe ze eruitzien. Het laten installeren van content types zorgt ervoor dat een Drupal gebruiker op een eenvoudige manier content kan toevoegen, in dit geval onderdelen van een CoAP-sensornetwerk. Concreet moet de gebruiker enkel op 'Add content' klikken op zijn/haar Drupal-website en het gewenste content type aanklikken. Na invullen van enkele vereiste velden wordt een node gecre\"{e}erd die de content voorstelt.
\newpage
\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/add_content}
\caption{Content toevoegen door op 'Add content' te klikken.}
\label{fig:addContent}
\end{figure}

\subsubsection{CoAP Resource}
\begin{wrapfigure}{r}{0.6\textwidth}
\vspace{-10pt}
%\hspace{-10pt}
\centering
\label{fig:addCoapResource}
\includegraphics[width=0.6\textwidth]{fig/add_coap_resource}
\vspace{-20pt}
%\hspace{-10pt}
\centering
\caption{Adding content of content type CoAP resource}
\centering
\vspace{-20pt}
\end{wrapfigure}
Dit content type stelt \'{e}\'{e}n resource voor. Bij het toevoegen wordt de URI opgegeven, deze bestaat uit het IPv6-adres van het embedded device waarop de resource is aangesloten en een URI-path. IPv6-adres en URI-path worden gescheiden door een slash ('/'). Een voorbeeld van een door ons vaak gebruikte URI is: 2001:6a8:1d80:200::2/test.\\
Er wordt gevalideerd op de structuur van de URI, wanneer de gebruiker een foute URI opgeeft wordt er een foutmelding getoond en krijgt de gebruiker opnieuw de kans om een geldige URI op te geven. Wanneer de URI gevalideerd is, krijgt de gebruiker de visuele representatie te zien. De gebruiker krijgt nu de kans om de REST-methodes  GET, PUT, POST en DELETE uit te voeren en een observe. Bovendien krijgt de gebruiker een geschiedenis van opvragingen voor deze resource te zien en krijgt hij ook de kans een grafiek te laten genereren. Voor het type grafiek heeft de gebruiker de keuze uit een lijn-, staaf-, of taartgrafiek. De gebruiker moet zelf weten welke soort grafiek nuttige informatie kan bevatten.
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{fig/coap_resource}
\caption{Visuele representatie van het content type CoAP resource.}
\label{fig:coapResource}
\end{figure}

\newpage
\subsubsection{CoAP Device}
\begin{wrapfigure}{r}{0.6\textwidth}
\vspace{-10pt}
%\hspace{-10pt}
\centering
\label{fig:addCoapDevice}
\includegraphics[width=0.6\textwidth]{fig/add_coap_device}
\vspace{-20pt}
%\hspace{-10pt}
\centering
\caption{Adding content of content type CoAP device}
\centering
\vspace{-20pt}
\end{wrapfigure}
Dit content type stelt een volledig embedded device voor waarop \'{e}\'{e}n of meerdere resources zich bevinden. Bij toevoegen van dit content type hoeft de gebruiker enkel het IPv6-adres op te geven. Aan de hand van resource discovery wordt dan een lijst van aangesloten resources opgebouwd en getoond aan de gebruiker. Nu kan de gebruiker doorklikken naar een resource die voorgesteld wordt aan de hand van het content type CoAP resource beschreven in de vorige subparagraaf.
\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{fig/coap_device}
\caption{Visuele representatie van het content type CoAP device.}
\label{fig:coapDevice}
\end{figure}

\section{Implementatie van de CoAP library-hooks}
In deze paragraaf bekijken we hoe deze module de hooks implementeert die de CoAP library voorziet (Zie paragraaf \ref{observe_hooks}).

\subsection{hook\_receive\_notification()}
Deze hook wordt opgeroepen door de CoAP library wanneer een bericht binnenkomt op de socket. Er wordt een response-object gemaakt van de klass CoAPMessage dat tevens meegegeven wordt als enige attribuut van de hook.\\
In deze module worden in de hook volgende stappen ondernomen:
\begin{itemize}
\item De benodigde waarden worden uit het response-object gehaald en in de databank gestopt voor de huidige gebruiker.
\item De user ID's van alle andere ge\"{i}nteresseerden (dus niet de huidige gebruiker) voor de betreffende resource worden opgehaald uit de databank.
\item Voor elk van deze users worden de waarden uit het response-object ook toegevoegd aan de databank.
\end{itemize}

\subsection{hook\_receive\_error()}
Deze hook wordt voorzien van de volgende parameters: een errorstring, het IPv6-adres van het embedded device en de naam van de resource. Ze wordt opgeroepen wanneer \'{e}\'{e}n van de volgende gebeurtenissen zich voordoet:
\begin{itemize}
\item De socket kon niet worden geopend naar het embedded device. Deze gebeurtenis resulteert in een errorstring gelijk aan 'unreachable'.
\item De tijdsspanne verstrijkt waarin een antwoord zou moeten ontvangen zijn, dit wordt bepaald met het exponential backoff-mechanisme (Zie paragraaf \ref{exponentialBackoff}). Dit levert een errorstring gelijk aan 'delay'.
\item Het maximum aantal pogingen om het bericht opnieuw te versturen is verstreken (Zie paragraaf \ref{exponentialBackoff}). Nu zal de errorstring gelijk zijn aan 'broken'.
\item Ook wanneer het zeker is dat er geen fout is opgetreden, wordt dit gemeld met deze hook. De errorstring wordt dan gelijk aan 'none'.
\end{itemize}
Wanneer nu de hook wordt opgeroepen voor de module die in dit hoofdstuk besproken wordt, zal de errorstring opgeslagen worden bij de betreffende resource in de databank.

\subsection{hook\_stop\_observers()}
Wanneer een observe moet be\"{e}indigd worden, om welke reden dan ook (bijvoorbeeld wanneer de resource niet meer te bereiken is), wordt deze hook opgeroepen. Deze krijgt als parameters het IPv6-adres van het embedded device en de naam van de resource mee. Zo kan de module die deze hook implementeert ervoor zorgen dat de toestand consistent blijft voor de andere users.\\
Concreet zal de module die in dit hoofdstuk wordt besproken, in de databank aanduiden dat users de betreffende resource niet meer aan het observeren zijn. Dit wordt voor elke user gedaan die ge\"{i}nteresseerd was in deze resource.

\section{Evolutie van de module} \label{evolutie}

\subsection{Temperatuurmodule met HTTP/CoAP-proxy} \label{proxy}
In deze paragraaf wordt besproken hoe de eerste versie van de module werd gemaakt die gebruik maakt van een HTTP/CoAP-proxy. Bovendien wordt ook aangetoond hoe waarden opgeslagen worden in de databank om de geschiedenis van opvragingen bij te houden. Eigenlijk spreken we hier (en in enkele volgende paragrafen) beter van een temperatuurmodule, aangezien deze module slechts \'{e}\'{e}n resource bevraagt. Het betreft een resource die de waarde van een temperatuursensor terugstuurt. Deze resource werd gekozen vanwege de numerieke waarde die teruggestuurd wordt en omwille van het feit dat de resource observable is.\\

De module wordt aan de gebruiker gepresenteerd onder de vorm van een Drupal block. Deze block bevat een HTML-formulier met twee componenten als invoer. Een checkbox die aanduidt of de gebruiker waarden automatisch wil laten ophalen, en een knop die het formulier indient wanneer de gebruiker erop klikt.\\
Wanneer de gebruiker op de knop klikt en de checkbox heeft aangevinkt, worden waarden automatisch opgehaald met een interval gelijk aan de waarde van de max age. Merk op dat het hier nog niet om een CoAP observe gaat, want die is enkel mogelijk met native CoAP, in deze module werken we met een HTTP proxy. Periodiek wordt een HTTP GET-request naar een HTML-pagina uitgevoerd. Wanneer de response ontvangen wordt, wordt de HTML-pagina geparsed, waarna de nuttige informatie in de databank wordt geplaatst. Met jQuery worden dan nieuwe waarden opgehaald en getoond aan de gebruiker.\\

Er is bij deze versie nog geen sprake van achtergrondprocessen waardoor het lang kan duren eer een pagina geladen wordt. Bovendien krijgt de gebruiker enkel een foutmelding (van de gebruikte webserver) te zien wanneer er geen communicatie mogelijk is.

\begin{figure}[h!]
\vspace{10pt}
\includegraphics[width=1\textwidth]{fig/TemperatuurModuleHTTPCOAPProxy}
\vspace{-30pt}
\caption{Temperatuurmodule met HTTP/COAP-proxy}
\vspace{-10pt}
\end{figure}

\subsubsection{Proxy}
Als proxy werd de coap.me website gebruikt van iMinds. Deze biedt de mogelijkheid om de notificaties van een embedded device te bekijken in een browser. De website biedt ook de mogelijkheid om door te klikken naar de notificatie om die volledig te bekijken op een pagina.\\

Het is deze laatste pagina die periodiek wordt opgehaald en geparsed. De communicatie vanwege de Drupal-module bestaat dus enkel uit HTTP-communicatie, de proxy verzorgt de nodige CoAP-berichten tussen zichzelf en het embedded device.

\subsubsection{Polling}
In deze eerste versie van de module bestond het antwoord bij de polling uit de volgende velden:
\begin{itemize}
\item Hid: De History ID dat een numeriek ID is voor de opgevraagde waarde. Het is tevens de index in de databanktabel met waarden en dus uniek.
\item Temperatuur: Dit is de effectieve waarde in graden Celsius. Deze werd geparsed uit een string die de resource teruggaf.
\item Max age: De antwoorden van de betreffende resource bevatten een Max-age optie. Dit is het aantal seconden dat deze waarde als geldig mag beschouwd worden.
\item Timestamp: Het tijdstip waarop de waarde ontvangen werd.
\end{itemize}

\subsection{Temperatuurmodule met native CoAP}
Nu de omliggende structuur opgezet en uitgetest is, kan de communicatie veranderen van HTTP berichten naar native CoAP. Er is in deze versie echter nog geen sprake van de CoAP library. Deze versie beperkt zich tot een eerste test met CoAP communicatie.\\

Voor CoAP verkeer zal het UDP protocol gebruikt worden zoals voorgeschreven in de CoAP draft \cite{coapDraft}. Eerst wordt een UDP socket geopend naar het betreffende IPv6-adres van het embedded device waarop de resource is aangesloten. Dit gebeurt met de functie pfsockopen() van PHP, deze opent een persistente socket. Vervolgens wordt een hexadecimale string opgesteld die het bericht voorstelt, ook deze opstelling gebeurt aan de hand van de CoAP draft \cite{coapDraft}. Het bericht wordt verstuurd met de fwrite() functie. Hierna kan het antwoord opgehaald worden van de socket met de fread() functie die als enige parameter een grootte in bytes ontvangt. Belangrijk hierbij is dat die grootte minstens voldoende is om het volledige antwoord te omvatten.\\

\subsubsection{Observe}
Nu er gebruik gemaakt wordt van native CoAP is nu ook een echte CoAP observe mogelijk. Hierbij is het noodzakelijk dat de socket opengehouden wordt, dit omdat het embedded device nu op eigen initiatief berichten kan sturen. Aangezien de socket moet worden opengehouden, kan de code niet meer op de voorgrond draaien. Indien dit wel zo zou zijn, zou de pagina blijven laden. De gebruiker zal dan geconfronteerd worden met een timeout van de webserver waarop Drupal draait. Achtergrondprocessen zijn nu dus geen optie meer, maar een noodzaak. De code om een socket open te houden en te beheren zal dus opgestart worden in een achtergrondproces aan de hand van de Background Process module die eerder al vermeld werd \cite{backgroundProcessModule}.\\
Bij ontvangst van een notificatie van de CoAP resource zal de waarde in de databank worden gestopt met bijbehorende velden. Deze velden zijn dezelfde als in de vorige versie van de module (Zie paragraaf \ref{proxy}). Het zijn deze waarden waarop de client zal pollen. Ook deze polling gebeurt op dezelfde manier als in de vorige versie van de module.

\subsection{CoAP Resource module met externe CoAP library}
Alle code die te maken had met CoAP communicatie was hardgecodeerde code wat onvermijdelijk leidde tot duplicatie van code. Bovendien bevond deze code zich in dezelfde module als diegene die nu wordt besproken. Dit heeft als gevolg dat andere gebruikers van Drupal geen gebruik kunnen maken van onze code om CoAP berichten te sturen en te ontvangen. Dit alles heeft geleid tot de ontwikkeling van onze eigen CoAP library in PHP onder de vorm van een externe module die apart kan worden gebruikt. Deze library werd eerder al besproken in hoofdstuk \ref{coaplibrary}.\\

\subsubsection{Nieuwe block}
De module onderging in deze stap ook een visuele verbetering, maar ook een verbetering qua functionaliteit (Zie figuur \ref{fig:meerdereResources}). Zo kan de gebruiker nu met \'{e}\'{e}n block meerdere resources bevragen.\\

De gebruiker kan \'{e}\'{e}n resource selecteren met radiobuttons, wanneer de gebruiker dan op de knop 'Bekijken' klikt, wordt de pagina herladen en is de geselecteerde resource te bevragen. Door op de knop 'GET' te klikken, wordt een GET-request uitgevoerd op de geselecteerde resource.\\
Er wordt ook een lijst met checkboxes ter beschikking gesteld. De gebruiker kan hierbij de resources aanvinken waarop een observe moet worden uitgevoerd. Wanneer de gebruiker een aangevinkte checkbox uitvinkt, zal de observe stoppen. De instellingen worden opgeslagen en de benodigde acties worden uitgevoerd wanneer de gebruiker op de knop 'Observe' klikt. Belangrijk hierbij is dat wanneer de pagina herladen wordt, de juiste checkboxes al worden aangevinkt zodat de gebruiker ten allen tijde weet welke resources al geobserveerd worden.\\
Een laatste verbetering bestaat uit een grafiek die automatisch wordt gegenereerd op basis van de geschiedenis van opvragingen. De grafiek wordt aan de hand van een AJAX call en de Google Charts API \cite{googleCharts} gerealiseerd. Het betreft hier de waarden van de resource die momenteel bekeken wordt en dus aangeduid is met een radiobutton.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/meerdere_resources}
\caption{Block met HTML-formulieren die de gebruiker toelaat meerdere resources met \'{e}\'{e}n block te bevragen.}
\label{fig:meerdereResources}
\end{figure}

\newpage

\subsection{CoAP Resource module met content type CoAP Resource}
In de vorige versies werd de module weergegeven aan de hand van een HTML-formulier in een Drupal block. Het nadeel hiervan is dat men standaard slechts \'{e}\'{e}n instantie van het block gebruikt. Men kan echter wel het een en het ander verbeteren met de Views module, maar het is niet de bedoeling dat wij dit verlangen van de gebruiker. Bovendien is een block slechts een visuele blok op de website, het is niet echt een node of een stuk content.\\

Een beter en vaak gebruikt alternatief is het maken van een eigen content type. Wanneer men nu deze module installeert worden de eigen content types mee ge\"{i}nstalleerd. Dit heeft als gevolg dat de gebruiker slechts op 'Add content' hoeft te klikken (Zie figuur \ref{fig:addContent}), enkele benodigde velden in moet vullen en de content wordt automatisch gegenereerd en opgeslagen. Bij deze methode wordt al deze configuratie afgehandeld door Drupal mechanismen, zo worden bijvoorbeeld de velden opgeslagen in tabellen die behoren tot de Drupal core. Dit betekent dat onze content effectief wordt ingepast en geen losstaand geheel is. Het beheer van de content, manipulatie en dergelijke zal dus gebeuren met Drupal zoals dat gebeurt voor andere content types.\\

\subsection{CoAP resource met volledige REST functionaliteit} \label{rest}
Tot hiertoe was enkel een GET-request mogelijk naar een resource, maar vaak ondersteunt een resource ook nog andere REST methodes (GET, PUT, POST, DELETE). Het is dus van groot belang dat onze module ook de mogelijkheid biedt om alle REST methodes uit te voeren.\\

Dit brengt ook mee dat de visuele representatie zal wijzigen (Zie figuur \ref{fig:rest}). De vier methodes worden met knoppen weergegeven in een tabel, eventueel vergezeld van een textbox indien invoer vereist is (PUT en POST). Onderaan de tabel wordt de response en response method getoond (205 Content, 405 Bad method,...).\\
Wij hebben ervoor gekozen dat de gebruiker voor elke resource, op elk moment elke REST methode kan uitvoeren. Er wordt namelijk al een gepaste response getoond wanneer een methode niet ondersteund is. Bovendien is een server niet verplicht in een resource discovery (Zie paragraaf \ref{resourceDiscovery}) aan te geven welke methodes ondersteund zijn. Wil men voor elke server toch methodes uitschakelen die niet ondersteund zijn, dan zou men al een keer moeten proberen en testen of een 405 Bad Request teruggestuurd wordt.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/rest}
\caption{Alle vier de REST methodes zijn nu ondersteund.}
\label{fig:rest}
\end{figure}

\subsection{CoAP Resource module met resource discovery}
De gebruiker kan nu al meerdere CoAP resources toevoegen aan zijn/haar website. Het kan echter moeilijk zijn een overzicht te behouden over al deze resources en bovendien moet men van elke resource de specifieke URI kennen.\\

Deze nadelen kunnen worden weggewerkt door gebruik te maken van resource discovery. De technische uitleg en implementatiedetails werden al besproken in paragraaf \ref{resourceDiscovery}. In deze module krijgt nu de gebruiker een lijst van CoAP resources te zien die aangesloten zijn op het embedded device. Om performantieredenen en omwille van het feit dat een well-known/core weinig of nooit verandert, wordt het resultaat van de resource discovery (Zie paragraaf \ref{resourceDiscovery}) opgeslagen in de databank. Dit gebeurt in verschillende kolommen, een kolom per attribuut dat geleverd wordt door de resource discovery. Er wordt echter op de website wel nog een Refresh-knop voorzien mocht de gebruiker de well-known/core toch willen vernieuwen.\\
Op de website wordt een resource weergegeven door de URI en de human readable name. Bovendien is voor elke resource ook een checkbox voorzien om aan te duiden dat de gebruiker ge\"{i}nteresseerd is in de resource. De gekozen worden dan opgesomd en ter beschikking gesteld op dezelfde manier als in de vorige versie van de module (Zie figuur \ref{fig:meerdereResources}). In de volgende twee subparagrafen bespreken we twee mogelijke vormen die wij gemaakt hebben om de resource discovery en opsomming van de resources te combineren.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/tabbladen}
\caption{Opsomming van resources aan de hand van resource discovery.}
\label{fig:tabbladen}
\end{figure}

\subsubsection{Multi-form}
Een eerste mogelijkheid bestaat erin eerst de lijst te presenteren aan de gebruiker. De gebruiker kiest dan een aantal resources die hij/zij wil toevoegen aan de website, waarna hij/zij op de knop 'Save' klikt. Hierna wordt een nieuwe pagina getoond die de gebruiker toelaat de resources te beheren en te bevragen (Zie figuur \ref{fig:meerdereResources}).

\subsubsection{Tabbladen}
Het nadeel bij het gebruik van een Multi-form is dat de gebruiker slechts \'{e}\'{e}n keer de kans krijgt om resources aan te duiden. De tweede mogelijkheid bestaat uit een pagina met tabbladen, zo kan de gebruiker steeds terugkeren naar de discovery om resources toe te voegen of te verwijderen. Merk op dat wanneer een resource verwijderd wordt, dit niet het geval is voor de waarden die ervan opgehaald zijn. Deze blijven aanwezig in de databank en zullen ook weer te zien zijn wanneer de resource later opnieuw wordt toegevoegd. Er zijn 3 tabbladen voorzien (Zie figuur \ref{fig:tabbladen}):
\begin{itemize}
\item Resources: Dit tabblad bestaat uit het block dat de gebruiker in staat stelt de resources te beheren en te bevragen zoals bij Multi-form en in de vorige versie van de module (Zie figuur \ref{fig:meerdereResources}).
\item Discovery: Dit tabblad toont de lijst van resources met bijbehorende checkbox (Zie figuur \ref{fig:tabbladen}).
\item Configuration: Dit tabblad is voorzien voor een configuratie die door de gebruiker kan worden ingesteld. Deze is echter niet ge\"{i}mplementeerd in deze module, maar kan wel toegevoegd worden in verder ontwerp (Zie paragraaf \ref{configuratie}).
\end{itemize}

\subsection{CoAP resource met meerdere content types}
Er is nog \'{e}\'{e}n nadeel dat de kop opsteekt bij de vorige versie van de module. De gebruiker kan nu namelijk geen aparte resource toevoegen zonder dat daar de functionaliteit van resource discovery bijkomt. We gaan er in deze, voor ons laatste, versie van de module voor zorgen dat een gebruiker kan kiezen of hij/zij een CoAP resource of een CoAP device toevoegt. Dit wordt gerealiseerd met de al eerder behandelde content types. Er worden nu twee content types gecre\"{e}erd bij installatie van de module, \'{e}\'{e}n voor een CoAP resource (Zie figuur \ref{fig:coapResource}) en \'{e}\'{e}n voor een CoAP device (Zie figuur \ref{fig:coapDevice}).\\

Wanneer een CoAP device wordt toegevoegd door de gebruiker, wordt er automatisch een resource discovery op uitgevoerd. De gebruiker krijgt dan een lijst van links te zien, \'{e}\'{e}n link per aangesloten CoAP resource (Zie figuur \ref{fig:coapDevice}). Bovendien wordt voor elk van die resources content aangemaakt van het content type CoAP resource. De gebruiker zal geen 2 gelijke resources kunnen toevoegen om duplicatie van content te vermijden. Wanneer de gebruiker toch dezelfde resource op verschillende plaatsen van de website wil krijgen, raden wij aan de Views module te gebruiken \cite{viewsModule}. Met Views kan men meerdere visuele representaties maken van dezelfde content, dus zonder content te dupliceren.

\subsubsection{Polling}
In vorige versies van de module had de gebruiker niet de kans om meerdere resources op \'{e}\'{e}n pagina te zetten met de Views module. Dit was in principe wel mogelijk, maar er zouden fouten optreden daar de polling gebeurde op basis van welke resource geselecteerd was. Dit selecteren van resources is in deze versie weggewerkt, elke resource is een op zichzelf staand geheel (Zie figuur \ref{fig:coapResource}). In deze versie is dit wel mogelijk omdat het polling mechanisme grondig werd aangepast zoals nu zal blijken.\\

Een poll gebeurt nu specifiek voor een URI die opgegeven wordt in de URL waarnaar een AJAX call wordt uitgevoerd. Bovendien werd in de databank een extra kolom 'New' toegevoegd aan de waardentabel. Deze duidt aan of een waarde reeds is opgehaald of nog niet (0 = reeds opgehaald, 1 = nog niet opgehaald). De kolom heeft als default waarde 1, dus nieuwe waarden worden automatisch als nieuw aangeduid. Wanneer een waarde opgehaald wordt uit de databank wordt de waarde in de kolom 'New' op 0 gezet.\\
Het pollen naar waarden voor een specifieke URI gebeurt nu als volgt:
\begin{itemize}
\item Er wordt in jQuery een AJAX call uitgevoerd naar een bepaalde URL, bijvoorbeeld http://localhost/coap\_resource/poll/2001:6a8:1d80:200::2\textbar test. In de URI wordt een slash vervangen door een rechte streep ('\textbar'), anders wordt de slash ge\"{i}nterpreteerd.
\item Op de webserver wordt in Drupal de URI uit de aanvraag-URL gehaald en worden de slashes terug geplaatst.
\item De URI wordt gebruikt in een select-query om de nog niet opgehaalde waarden op te halen, dit wil zeggen de rijen waarvan de waarde in de kolom 'New' op 1 staat.
\item Er wordt een update-query uitgevoerd om van de opgehaalde rijen de waarde in de kolom 'New' te wijzigen naar 0. Dit om aan te geven dat de waarden reeds opgehaald werden.
\item De opgehaalde rijen worden in een XML-structuur gegoten samen met identificatie van de resource (de URI) en een eventuele errorstring. Deze XML-structuur wordt na deze stappen toegelicht.
\item De XML-structuur wordt uitgeprint en dus teruggestuurd als antwoord op de AJAX call.
\item in jQuery wordt dan het antwoord geparsed. De errorstring wordt eruit gehaald en eventuele fouten worden getoond aan de gebruiker (Zie paragraaf \ref{foutmechanisme}). Daarna wordt elke opgehaalde rij \'{e}\'{e}n voor \'{e}\'{e}n overlopen en toegevoegd aan de visuele content die de gebruiker ziet.
\end{itemize}

De XML-structuur die eerder werd aangehaald bestaat uit een allesomvattend hoofdelement \textless poll\textgreater. Dit element bevat 3 andere soorten elementen:
\begin{itemize}
\item \textless uri\textgreater: Dit element komt \'{e}\'{e}n keer voor, het bevat de URI en dus de identificatie van de resource.
\item \textless error\textgreater: Net als het vorige element komt dit element ook \'{e}\'{e}n keer voor, het bevat de eventuele errorstring. Deze kan \'{e}\'{e}n van de volgende zijn: none, delay, broken of unreachable.
\item \textless entry\textgreater: Dit element stelt een rij voor met een waarde. Dit element kan dus nul of meer keren voorkomen. Het bestaat zelf uit de volgende elementen:
\begin{itemize}
\item \textless Hid\textgreater: de history ID van de rij.
\item \textless Value\textgreater: de effectieve (eventueel geparsete) waarde van de rij.
\item \textless Max age\textgreater: Het aantal seconden dat deze waarde als geldig mag worden beschouwd.
\item \textless Timestamp\textgreater: Het tijdstip waarop de waarde ontvangen werd op de Drupal server.
\end{itemize}
\end{itemize}

Een voorbeeld van een antwoord op een AJAX call bij polling:

\lstset{language=XML}

\begin{lstlisting}[label=xmlPolling,caption=Voorbeeld antwoord op AJAX call bij polling]
<poll>
	<uri>2001:6a8:1d80:200::2</uri>
	<error>none</error>
	<entrys>
		<entry>
			<hid>76</hid>
			<value>20.2</value>
			<max_age>30</max_age>
			<timestamp>2013-05-20 20:36:32</timestamp>
		</entry>
		<entry>
			<hid>77</hid>
			<value>20.4</value>
			<max_age>30</max_age>
			<timestamp>2013-05-20 20:36:37</timestamp>
		</entry>
	</entrys>
</poll>
\end{lstlisting}

\subsubsection{Templating}
Nu de functionaliteit min of meer op punt staat, wordt het tijd voor visuele opmaak. En dit op een manier die aangeraden wordt door de Drupal community, waarbij de view netjes gescheiden wordt. Concreet maken we een template voor het content-type CoAP resource. Drupal voorziet hier een handig mechanisme voor, men kan namelijk een template maken voor een specifiek content-type. Het enige wat men moet doen om ervoor te zorgen dat die template automatisch wordt opgeroepen voor het content-type, is het template-bestand de juiste naam geven. Drupal voorziet namelijk in alle themes een standaard template voor een node, namelijk node.tpl.php. Om nu onze template te defini\"{e}ren, moet deze de naam node--coap\_resource.tpl.php dragen, daar de naam van ons content-type coap\_resource is.\\

Het voordeel van deze benadering is dat men in dit bestand HyperText Markup Language (HTML) \nomenclature{HTML}{HyperText Markup Language} kan schrijven. Wanneer men bepaalde attributen of content nodig heeft voor de visuele representatie, kan men die variabelen voorzien door gebruik te maken van de hook hook\_preprocess\_node(). Deze hook wordt op voorhand opgeroepen en variabelen worden klaargezet. In het template-bestand kan men deze variabelen bereiken aan de hand van PHP-scriptlets (Zie listing \ref{template}). Men kan in deze templates dus ook PHP-code laten uitvoeren, al beperkt men dit best tot een minimum om de view gescheiden te houden. Concreet worden bij ons de URI van de resource en enkele waarden gebruikt in het template-bestand.\\

Er stelt zich nu wel nog een probleem, het template-bestand moet namelijk op de juiste plaats staan, en dit in de directory van het gebruikte theme. Men voegt echter beter geen bestanden toe aan de Drupal core en bovendien kunnen wij dat ook niet verwachten van de eindgebruiker. Het template-bestand zou automatisch moeten worden opgenomen in het gebruikte theme, waarbij het template-bestand gewoon in onze module kan blijven staan. Na grondig onderzoek bleek dit mogelijk aan de hand van een hook, namelijk de hook hook\_theme\_registry\_alter(). Die geeft ons de kans een pad toe te voegen aan het theme-registry, waardoor het template zal gevonden worden bij het bouwen van de view \cite{addTemplate}.

\lstset{language=HTML}

\begin{lstlisting}[label=template,caption=Voorbeeld van een template met PHP-scriptlets (node.tpl.php)]
<div id='node-<?php print $node->nid; ?>' >
	<?php print render($title_prefix); ?>
	<?php if (!$page): ?>
	<h2<?php print $title_attributes; ?>>
		<a href='<?php print $node_url; ?>'>
			<?php print $title; ?>
		</a>
	</h2>
	<?php endif; ?>
	<?php print render($title_suffix); ?>
</div>
\end{lstlisting}

\subsubsection{Foutmechanisme} \label{foutmechanisme}
Tot nog toe bleef de gebruiker in het ongewisse wanneer er iets foutliep in de communicatie met een CoAP resource. Dit is niet gebruiksvriendelijk en kan voor ergernissen zorgen.\\
Nu hebben we in de vorige hoofdstukken al gezien dat fouten al geregistreerd worden aan de hand van enkele errorstrings. Deze zijn zelfs al ter beschikking in jQuery bij elke poll (Zie polling hierboven). Het enige wat nu nog moet gebeuren is een gepaste boodschap tonen in de visuele representatie. Zoals te zien in figuur \ref{fig:foutmechanisme} wordt in het groen een vinkje getoond wanneer een operatie geslaagd is. Wanneer de communicatie niet gelukt of foutgelopen is wordt de methode geannuleerd en wordt een kruisje in het rood getoond. Ook wanneer een methode niet ondersteund is, wordt dit kruisje getoond. Wanneer het antwoord op zich laat wachten worden roterende blauwe pijltjes getoond.

\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{fig/foutmechanisme}
\caption{Mechanisme om fouten te tonen aan de gebruiker.}
\label{fig:foutmechanisme}
\end{figure}
